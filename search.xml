<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络设备相关基础知识合集</title>
      <link href="/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
      <url>/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<ul><li>交换机的硬件构成</li></ul><p>    - 主板</p><p>    - CPU</p><p>        - 交换机使用特殊用途的集成电路芯片ASIC，以实现高速的数据传输</p><p>    - 存储介质</p><p>        - ROM（只读存储器）</p><p>            - 存储开机诊断程序，引导程序和简单操作系统软件</p><p>        - FLASH（ROM）（闪存）</p><p>            - 存储系统软件映像文件和VLAN数据库文件等，其功能类似于计算机中的硬盘，是可擦除，可编程的ROM。</p><p>        - NVRAM（非易失性随机存储器）</p><p>            - 存储启动配置文件</p><p>        - RAM&#x2F;DRAM（动态随机存储器）</p><p>            - 主存储器，存储运行配置文件</p><p>    - 端口</p><p>        - 快速以太网端口</p><p>        - 吉比特以太网端口</p><p>        - 控制端口（console）</p><p>    - 交换机加电启动，硬件运行过程</p><p>        - 加电开启自检，ROM（只读存储器，断电后不丢失数据，里面存放mini IOS boot）指导flash（闪存）里面的bin文件，也就是操作系统，从NVRAM（非易失性随机存储，断电不丢失数据）加载启动配置文件，以及在flash中读取vlan.dat文件，最终所有在RAM（随机存储）中执行。</p><p>        - ROM-FLASH-NVRAM—RAM</p><ul><li>交换机基础概念</li></ul><p>    - （Switch）是一种用电（光）信号转发的网络设备，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。</p><p>    - 交换机位于OSI参考模型的数据链路层</p><ul><li>交换机配置方式</li></ul><p>    - 用配置口（Console）</p><p>    - Telnet</p><p>    - Web端</p><ul><li>基本命令</li></ul><p>    - 设置密码(特权模式)：# enable passwd ******</p><p>    - 设置主机名（以下命令均在特权模式下）：# hostname ****</p><p>    - 设置密码（Console）: # line console 0 # login # password *****</p><p>    - 设置密码（虚拟终端）： # line vty 0 4 #  login #  passwd *****</p><p>    - 设置IP地址，子网掩码： # ip address 192168.1.1 255.255.255.0 (#  no shutdown)</p><p>    - 设置默认网关： #  ip default-gate 192.168.1.254</p><p>    - 禁用DNS服务 # no ip domain-lookup</p><p>    - 保存配置： #  write#  copy running-config startup-config</p><p>    - show:(均在全局模式下) # show history # show mac-address-table # show version # show running-config # show interface fa0&#x2F;1</p><ul><li>VLAN</li></ul><p>    - 概述：虚拟局域网（VLAN）是一种将物理局域网根据某种网络特征从逻辑上划分（注意，不是从物理上划分）成多个网段，从而实现虚拟工作组内的数据交换的技术。 划分后的VLAN具有局域网的所有特征，一个VLAN内部的广播和单播流量不会转发到其他VLAN中，从而可以隔离网络上的广播流量、提高网络的安全性。</p><p>    - 为什么划分VLAN： 没有划分VLAN的传统局域网处于同一个网段，是一个大的广播域，广播帧占用了大量的带宽，当网络内的计算机数量增加时，广播流量也随之增大，广播流量大到一定程度时，网络效率急剧下降，所以给网络分段是一个提高网络效率的办法。</p><p>    - 作用： 1.提高了网络通信效率。由于缩小了广播域，一个VLAN内的单播、广播不会进入另一个VLAN，减小了整个网络的流量。 2.方便了维护和管理。VLAN是逻辑划分的，不受物理位置的限制，给网络管理带来了方便。 3.提高了网络的安全性。不同VLAN之间不能直接通信，杜绝了广播信息的不安全性。要求高安全性的部门可以单独使用一个VLAN，以有效防止外界的访问。</p><p>    - 划分VLAN的方式： 1.基于端口划分VLAN 2.基于MAC地址划分VLAN 3.基于网络层协议划分VLAN</p><p>    - 交换机的端口类型 1.Access端口：实现二层交换功能，只转发来自同一个VLAN的数据帧。 2.Trunk端口：实现二层交换功能，可转发来自多个VLAN的数据帧。</p><ul><li>VLAN基本命令</li></ul><p>    - 创建VLAN： # vlan (数字) （删除VLAN则在前面加一个 no）</p><p>    - VLAN命名： # (vlan) name vlan-name</p><p>    - 将交换机端口分配给某个VLAN的命令： Switch(config)# interface fa0&#x2F;1 Switch(config-if)# switchport mode access Switch(config-if)# switchport access vlan 20 Switch(config)# interface range fa0&#x2F;5–10,fa0&#x2F;15 Switch(config-if)# switchport mode access Switch(config-if)# switchport access vlan 20</p><p>    - 进入多个端口（用于同时给多给端口设置VLAN）： interface range f0&#x2F;5–10,f0&#x2F;24 Interface range vlan 2-4</p><p>    - 端口描述（不常用但是我还是写上）： （接口配置模式）Description string</p><p>    - 端口的双工：Duplex {auto|full|half}</p><p>    - 端口速率：Speed {10|100|1000|auto}</p><p>    - 端口的流控： Flowcontrol {auto|on|off}</p><ul><li>交换机（三层）</li></ul><p>    - 工作原理： 1.三层交换机是将二层交换机与路由器有机结合的网络设备，它既可以完成二层交换机的端口交换功能，又可以完成路由器的路由功能。</p><p>        - 进入三层交换机的数据帧，如果源和目的MAC地址在同一个VLAN，数据交换会采用二层交换方式；如果源和目的MAC地址不在同一个VLAN，则会将数据帧拆封后交给网络层去处理，经过路由选择后，转发到相应的端口。</p><p>        - 当某一信息源的第一个数据流进入三层交换机后，其中的路由系统将会产生一个MAC地址与IP地址映射表，并将该表存储起来，当同一信息源的后续数据流再次进入第三层交换机时，交换机将根据第一次产生并保存的地址映射表，直接从二层由源地址转发到目的地址，而不需要再经过第三层的路由系统处理，即“一次路由、多次交换”。</p><p>    - 配置</p><p>        - 使用no switchport 改变端口的二层特性。改回二层端口则是使用 switch port 。请注意，从三层路由端口改为二层交换端口时，原先设置的IP地址就无效了</p><p>    - 配置三层交换机实现VLAN间通信 （1）将三层交换机接入二层交换机的端口配置为Trunk。 （2）在三层交换机上创建VLAN，并进入VLAN接口，配置IP地址。这个IP地址将作为相应VLAN内计算机的默认网关。 （3）启动三层交换机路由功能 Ip routing</p><ul><li>端口安全</li></ul><p>    - 概述：端口安全，是指通过限制允许访问交换机上某个端口的MAC地址以及IP地址（可选）来实现对该端口输入的严格控制。 当为安全端口（打开了端口安全功能的端口）配置了安全地址后，除了源地址为这些安全地址之外，该端口将不转发其他任何数据帧。</p><p>    - MAC地址</p><p>        - 动态MAC地址：交换机主动学习MAC地址，当端口状态改变时，将重新学习并更新MAC地址表。</p><p>        - 静态MAC地址：人为将“端口与MAC地址”进行绑定，并加入表中，该端口不再主动学习。</p><p>        - 粘性MAC地址：首次主动学习MAC地址并绑定，当端口状态再次改变时，该端口不再主动学习。</p><p>    - 基本功能</p><p>        - 限制交换机端口的最大连接数。</p><p>        - 端口的安全地址绑定，如在端口上同时绑定IP和MAC地址，可以防ARP欺骗；在端口上绑定MAC地址，并限制安全地址数为1，可以防恶意DHCP请示。</p><p>    - 安全违例的处理方式</p><p>        - 保护(Protect)：丢弃未允许的MAC地址流量，但不会创建日志消息。</p><p>        - 限制(Restrict)：丢弃未允许的MAC地址流量，创建日志消息并发送SNMP Trap消息。</p><p>        - 关闭(Shutdown)：默认选项，将端口置于err-disabled状态，创建日志消息并发送SNMP Trap消息。若要重新开启该端口，需要“先关闭再打开”端口或使用errdisable recovery命令。后者在模拟器上无法使用。</p><p>    - 基本命令：</p><p>        - 启用端口安全功能： # (if)switchport port-security</p><p>        - 端口安全最大连接数配置： # （if）switchport port-cecuritu maximum value</p><p>        - 端口地址绑定： # （if）switchport port-securitu mac-address +(mac地址) ip-addess +(ip地址)</p><p>        - 设置处理违例方式： # （if）Switchport port-security violation [protect&#x2F;restrict&#x2F;shutdown] (注意：当端口因为违例而被关闭后，必须在该端口下，先运行命令shutdown，再运行命令no shutdown，才可开启该端口。)</p><p>        - 粘性MAC地址： # （if）switchport port-security mac-address sticky</p><p>        - 查看端口安全信息： # show port-security interface +(端口名)</p><ul><li>端口聚合</li></ul><p>    - 作用： 通过端口聚合，可以提高端口间链路的通信速度。比如，当用2个100Mb&#x2F;s的端口进行聚合时，所形成的逻辑端口的通信速度为200Mb&#x2F;s；若用4个，则为400Mb&#x2F;s。当以太通道内的某条链路出现故障时，该链路的流量将会自动转移到其余链路上，自动提供冗余和负载均衡。</p><p>    - 概述： 端口聚合也叫作以太通道（ethernet channel），主要用于交换机之间连接。 由于两台交换机之间有多条冗余链路时，STP会将其中的几条链路关闭，只保留一条，这样可以避免二层的环路产生。但是，失去了路径冗余的优点。 使用以太通道，交换机会把一组物理端口联合起来，作为一个逻辑通道channel-group，这样交换机会认为这个逻辑通道是一个端口。</p><p>    - 端口聚合协议： 端口聚合可采用手工方式进行配置，也可使用动态协议来聚合。 1.PAGP（Port Aggregation Protocol，端口聚合协议）是Cisco专有的端口聚合协议。 2.LACP（Link Aggregation Control Protocol，链路聚合控制协议）是一种标准的协议。</p><p>    - 基本命令：</p><p>        - Channel-group number mode [active|auto|desirable|on|passive] (其中number为通道组号，二层交换机的组号范围是1-6，三层交换机的组号范围是1-48。)</p><p>        - Switch(config)# interface range fa0&#x2F;23 – 24 &#x2F;&#x2F;配置fa0&#x2F;23和fa0&#x2F;24端口 Switch(config-if-range)# channel-group 10 mode on &#x2F;&#x2F;把fa0&#x2F;23和fa0&#x2F;24端口加入10号通道组</p><p>        - 配置负载均衡： # （if）Port-channel load-balance +(方式) （一般使用 dst-mac）</p><p>        - 其他负载均衡方式： dst-ip,dst-mac,src-dst-ip,src-dst-mac</p><p>        - 查看配置 Switch# show etherchannel summary</p><p>        - 进入通道组： （conf）# interface port-channel 10</p><p>        - 通道组封装trunk协议：(注意！！！) # （if）switchport trunk encapsulation dot1q # （if）switchport mode trunl</p><ul><li>STP （生成树协议）</li></ul><p>    - 概述： 生成树协议（Spanning Tree Protocol，STP）通过生成树算法在一个具有冗余链路的网络中构成一个没有环路的树形逻辑拓扑结构，既提供了链路的冗余连接，增强了网络的可靠性，又避免了数据在环路上的连续转发，消除了广播风暴。</p><p>        - 生成树从一开始到完全收敛需要经过以下4步： （1）在所有交换机中选举一个网桥作为根桥。 （2）在每个非根桥交换机中选择一个端口作为根端口。 （3）在每条链路上选定一个端口作为该链路的指定端口。 （4）既不是根端口也不是指定端口的将会被阻塞。</p><p>    - 冗余链路： 在局域网中，为了增加网络的高可用性，会在接入层与汇聚层之间实施冗余链路，这样将导致二层网络中出现环路。如下图所示的冗余链路，使得数据帧到达目的主机的链路会增多，从而使数据帧在交换机之间不断被转发，形成一个环路。</p><p>        - - 形成环路带来的问题： （1）形成广播风暴。 （2）MAC地址表不稳定。 （3）重复的帧复制。</p><p>    - STP版本</p><p>        - （1）Common Spanning Tree（CST） （2）Rapid Spanning Tree Protocol（RSTP） （3）Per-VLAN Spanning Tree plus（PVST+） （4）Rapid PVST+ （5）Multiple Spanning Tree Protocol（MSTP）</p><p>    - STP名词：</p><p>        - 网桥ID（Bridge ID） 网桥ID是由网桥优先级和MAC地址的组合来决定的，在网络中，网桥ID最小的网桥就成为根桥。</p><p>        - 网桥桥协议数据单元（Bridge Protocol Data Unit，BPDU) 网桥协议数据单元是所有交换机之间都交换的信息，并利用这些信息来选出根交换机或进行网络的后续配置。在选举之前，每个交换机都会将自己的根ID设置为自身的网桥ID，一旦选举失败，交换机就会将自己的根ID替换为根桥的网桥ID。</p><p>        - 非根桥（Nonroot Bridge） 除了根桥外，其他所有的网桥都是非根桥。它们相互之间交换BPDU，并在所有交换机上更新STP拓扑数据库以防止环路，并对链路失效采取补救措施。</p><p>        - 开销（Port Cost） 用来衡量非根桥到根桥的带宽的指标，非根桥到根桥路径的开销等于各段链路开销之和。</p><p>        - 根端口（Root Port） 非根桥的所有端口到根桥路径开销最低的端口叫做非根桥的根端口，根端口只能出现在非根桥上，它在生成树的运行中处于转发状态。</p><p>        - 指定端口（Designated Port） 每个链路或二层网络中，距离根交换机开销最小的接口叫做该网段的指定接口，根交换机的所有端口都是其所在链路的指定端口，它在生成树的运行中处于转发状态。</p><p>        - 非指定端口（Nondesignated Port） 既不是指定端口也不是根端口的叫做非指定端口，它将被设置为阻塞状态。</p><p>        - 除了以上的术语外，如果某个端口能够转发数据帧，称之为转发端口；如果某个端口不能转发数据帧，则称之为阻塞端口，这样是为了防止产生环路。</p><p>    - 选举根桥与根端口</p><p>        - 根桥的选举规则如下： （1）在选举过程中，优先级高（数字越小）的将被直接选举为根桥。 （2）在优先级相同的情况下，MAC地址越小将成为根桥。 （3）Cisco的交换机默认优先级为32768，这是由IEEE802.1d定义的。数字越小表示优先级越高，另外，优先级可以配置的范围是从0以4096为单位递增至61440。</p><p>        - 根端口的选举规则如下： （1）在选举过程中到达根桥开销最低的路径，所连接的端口就是根端口。 （2）如果有多条等价路径，那么比较上游BPDU发送者的BID，与BID最小的交换机相连的端口就是根端口。</p><p>        - 指定端口的选举规则如下： （1）在根桥上的所有端口都是指定端口，因为端口开销都是0。 （2）在两个非根桥之间的端口中，选择到达根桥路径开销较小的端口成为指定端口。 （3）在两个非根桥之间的端口中，如果到达根桥的路径开销一样，那么选择这两个端口所属的非根桥中BID较小的端口成为指定端口。 （4）在两个非根桥之间的端口中，如果到达根桥的路径开销一样，并且所属非根桥的BID也相同（即同一交换机），那么需要在这两个端口中选举出PID较小的端口成为指定端口。</p><p>        - 既没有被选举为根端口，也没有被选举为指定端口，这些端口被称为非指定端口，非指定端口将被置为阻塞状态，也即不能转发数据。</p><p>    - STP配置命令</p><p>        - 修改网桥优先级值： （conf）# spannning-tree vlan vlan 10 priority 4096 (范围：0-61440)</p><p>        - 指定当前交换机为根桥： （conf）# spanning-tree vlan 10 root primary</p><p>        - 配置交换机的端口优先级： （if）# spanning-tree vlan 10 port-priority 16 (范围：0-240，默认128)</p><ul><li>端口 状态</li></ul><p>    - 阻塞（Blocking）状态： 被阻塞的端口称为非指定端口，即这个端口不能转发数据帧，它只监听BPDU帧。设置阻塞状态的目的是防止二层网络环路的产生。</p><p>    - 侦听（Listening）状态： 在20秒计时结束后，非阻塞端口就会进入侦听状态。端口在侦听状态下会接收并处理BPDU，并仔细计算以确保在传送数据帧之前网络上没有环路产生。同时，会向相邻交换机发送BPDU，通知相邻交换机自己将会参与到激活拓扑的过程中，这个状态的转发延迟时间大约是15秒。</p><p>    - 学习（Learning）状态： 根端口和指定端口将从侦听状态转换到学习状态。在学习状态下，交换机端口将会侦听BPDU，但与侦听状态不同的是，学习状态下的端口不仅会接收BPDU，还可以记录和更新其MAC地址或端口地址表。端口处于这种状态的转发延迟时间默认为15秒左右。</p><p>    - 转发（Forwarding）状态： 在转发延迟计时期满后，如果该端口仍然是指定端口或根端口，它就会进入转发状态。在桥接的端口上，处在转发状态的端口发送并接收所有的数据帧，并更新其MAC地址表或端口地址表，最后通过相应的端口转发用户的流量。 只有在学习状态或转发状态下，交换机才能填写MAC地址表。</p><p>    - 禁用（Disable）状态： 这种状态是一种特殊的状态，从管理上讲，处于禁用状态的端口不能参与帧的转发或参与STP。这可能是为了将此端口从STP中移出，该端口被管理员手动关闭所造成的，又或者是物理层的链路出现故障造成的。处于禁用状态下，端口实质上是不工作的。 大多数情况下，交换机端口都处在阻塞状态或转发状态。</p><ul><li>路由器</li></ul><p>    - 路由器基础</p><p>        - 硬件构成</p><p>            - CPU</p><p>                - 路由器的中央处理器</p><p>            - ROM</p><p>                - 存储开机诊断程序，引导操作系统软件备份。作为只读存储器，即使断电程序也不会丢失。</p><p>            - RAM&#x2F;DRAM</p><p>                - 路由器的主存储器。用于存储路由表，保持ARP缓存，完成数据包缓存。开机后为配置文件提供短暂的内存，关机或重启后，数据便会消失。</p><p>            - FLASH</p><p>                - 用于存储系统软件映像等，是可擦除，可编程的ROM。Flash中的程序掉电不丢失。</p><p>            - NVRAM</p><p>                - 用于存储启动配置文件。</p><p>            - 接口</p><p>                - 许多路由器都有“网络模块插槽”，这种路由器被称为模块化路由器。</p><p>                    - 局域网接口</p><p>                        - 双绞线以太网接口</p><p>                        - 光纤接口</p><p>                    - 广域网接口</p><p>                    - 配置接口 （console）</p><p>        - 串口配置</p><p>            - 路由器接口比交换机的少很多，为了满足路由器与多台设备连接的需求。我们为路由器添加串口。</p><p>                - 在模拟器中，先点开路由器的物理配置界面。关闭电源，找到对应的物理配置接口，用鼠标拖动至控模块中，再开启电源。</p><p>                    - （WIC-2T模块）</p><p>                    - 安装好后就多了两个Serial接口</p><p>                - 配置串口后连接设备需要特别的命令配置。即DCE端（有时钟符号标识端）需要配置时钟频率。</p><p>                    - 进入端口： (config)# interface serial 0&#x2F;0&#x2F;1 绑定地址： (config-if)# ip address xxx.xxx.x.x 255.255.255.0 DCE口配置时钟频率： (config-if)# clock rate 64000 开启端口： (config-if)# no shut</p><p>        - 路由器工作原理</p><p>            - 路由器位于OSI参考模型的第三层（网络层），用于连接不同的网络，具有存储，转发，寻径功能。路由器会根据路由表中的信息，选择合适路径将数据转发出去</p><p>            - 路由决策原则：</p><p>                - 按最长匹配原则。当有多条路径到达目标时，以其IP地址或网络号最长匹配的作为最佳路由。</p><p>                    - eg.在10.1.1.1&#x2F;8,10.1.1.1&#x2F;16,10.1.1.1&#x2F;32中选择 &#x2F;32，因为它是具体的IP地址</p><p>                - 按最小管理距离优先原则。再相同匹配长度的情况下，按照路由的管理距离：管理距离越小，路由越优先。</p><p>                    - eg. S 10.1.1.1&#x2F;8 为静态路由， R10.1.1.1&#x2F;8为RIP产生的动态路由，静态路由的默认管理距离值为1，RIP默认管理距离值为120。故选择静态路由。</p><p>                - 按度量值最小优先原则。当匹配长度和管理距离都相同时。比较路由的度量值（代价）。度量值越小越优先。</p><p>                    - eg. S 10.1.1.1&#x2F;8[1&#x2F;20]（其度量值为20 )；S 10.1.1.1&#x2F;8[1&#x2F;40]（其度量值为40)。所以选前者。</p><p>            - 路由表</p><p>                - 路由表一般包含以下字段：</p><p>                    - 目标网络地址&#x2F;掩码字段</p><p>                    - 管理距离&#x2F;度量值</p><p>                    - 下一跳地址字段</p><p>                    - 路由更新时间字段</p><p>                    - 输出接口字段</p><p>        - 路由种类</p><p>            - 直连路由</p><p>                - 定义接口IP地址，激活了该接口，路由器就会自动激活端口IP所在网段的直连路由信息，即直连路由。</p><p>                - 路由器的每个接口必须单独占用一个网段，几个接口不能同属于一个网段</p><p>            - 静态路由</p><p>                - 优点：简单高效可靠，网络安全保密性高。</p><p>                    - 配置命令 ip route (目标网络号)（子网掩码） （下一跳地址或本地接口）</p><p>                - 默认路由是静态路由的一种特殊情况。</p><p>                    - 配置命令 ip route 0.0.0.0 0.0.0.0（下一跳地址或本地接口）</p><p>                - 浮动路由</p><p>                    - 浮动路由是指对同一个目的网络，配置下一跳不同，且优先级不同的多条静态路由。正常情况下只有优先级最高的路由在起作用。当线路失效时，次优先静态路由启动，以保证网络总是可达。</p><p>                        - 优先级设置eg： IP route 192.168.1.0 255.255.255.0 192.168.10.2 250</p><p>            - 动态路由</p><p>                - 详见后续</p><p>    - 单臂路由</p><p>        - 概念：单臂路由是指在路由器的一个接口上通过配置子接口（逻辑接口）的方式，实现原来互相隔离的不同VLAN之间的互相联通。</p><p>        - 配置命令</p><p>            - 进入子接口： （config）# interface fa0&#x2F;0.1</p><p>            - 封装协议：（config-subif）# encapsulation dot1 vlan号</p><ul><li>DHCP</li></ul><p>    - 路由器DHCP</p><p>        - 工作原理</p><p>        - 工作过程</p><p>            - 1)DHCP客户端发从DHCP DISCOVER的广播信息到网络中，以便于能寻找一台提供IP地址的DHCP服务器、</p><p>            - 2）DHCP服务器收到DHCP客户端的DHCP DISCOVER信息后，就会从IP地址池中挑选一个尚未出租的IP地址，利用广播的方式传送给DHCP客户端。</p><p>            - 3）当DHCP客户端挑选好第一个收到的DHCP OFFER信息后，就利用广播的方式，响应一个DHCP REQUEST信息给DHCP服务器</p><p>            - DHCP服务器收到DHCP客户端要求IP地址的DHCP REQUEST信息后，就会利用广播的方式送出DHCP ACK 确认信息给DHCP客户端。客户端收到信息后便完成了获取IP 地址的步骤。</p><p>        - 命令</p><p>            - 设置DHCP动态地址池名： （config）# ip dhcp pool (地址池名)</p><p>            - 设置分配网段： （DHCP-config）# network IP地址 子网掩码</p><p>            - 设置网关地址： （DHCP-config）# default-router ip地址</p><p>            - 设置DNS服务器地址： （DHCP-config）# dns-serber IP地址</p><p>            - 设置排除DHCP所分配的IP地址范围： （config）# ip dhcp excluded-address 起始IP地址 终止IP地址</p><p>            - 查看DHCP已分配地址信息： # show IP dhcp binding</p><p>        - DHCP中继</p><p>            - 作用：当客户端主机与DHCP服务器不在同一个网段时，因为请求服务需要广播，而广播无法跨网段。因此需要DHCP中继。</p><p>            - 命令:(config-if)# ip helper-address ip地址</p><p>    - 三层交换机DHCP</p><p>        - DHCP原理</p><p>            - 交换机的DHCP与路由器的相似，相同部分不再赘述。</p><p>        - DHCP Snooping</p><p>            - 作用： 1）通过对客户端和服务器之间的DHCP交互报文进行窥探，实现对用户的监控。 2）通过合理的配置实现对非法服务器的过滤，防止用户获取到非法的DHCP 服务器提供的网址而无法上网。</p><p>            - TRUST口：把合法的DHCP Server连接的端口设为TRUST口，其他为untrust,就可以实现对非法DHCP服务器的屏蔽</p><p>            - 命令</p><p>                - 开启DHCP snooping: (config)# ip dhcp snooping (config)# ip dhcp snooping vlan vlan号</p><p>                - 连接DHCP服务器的接口配置为可信任口： (config-if)# ip dhcp snooping trust</p><p>    - IPv6DHCP</p><p>        - 设置IPv6 DHCP地址池地址前缀 名字为V6pool: (config)# ipv6 local pool v6pool 2023:1:1:3::&#x2F;64</p><p>        - 设置IPv6 DHCP地址池 名为dhcp - pool: (config)# ipv6 dhcp pool dhcp-pool</p><p>        - 地址池前缀委派： (config-dhcp)# prefix-delegation pool v6pool</p><p>        - 设置 DHCP分配的DNS服务器地址： （config-dhcp）# dns-server 2001:1::1 （config-dhcp）# exit</p><p>        - 开启IPv6的DHCP功能并绑定地址池： (config)# interface f0&#x2F;0 (config-if)# ipv6 dhcp server dhcp-pool</p><p>        - 将RA报文的M（managed[管理]）位置设为1： （config-if）# ipv6 nd managed-config-flag</p><p>        - 将RA报文的O（other）位置设为1： （config-if）# ipv6 nd other-config-flag</p><p>        - # show ipv6dhcp binding</p><ul><li>IPv6</li></ul><p>    - 组成</p><p>        - IPv6地址长度128位，由8个16位子字段组成，相邻字段用冒号分隔。IPv6地址中的每个字段都必须包含一个十六进制数字。</p><p>        - 公共拓扑（站点前缀）：站点前缀用于定义从网络到路由器的公共拓扑，占48位。（对应IPv4 的网络号）</p><p>        - 站点拓扑(子网ID)：子网ID定义用于网络管理的管理子网，描述站点拓扑，它的最大长度外地16位。</p><p>        - 接口ID：接口ID用来标识特定节点的接口。</p><p>        - IPv6相邻节点搜索（Neihbor Discovery,ND协议）协议简化了IPv6的地址配置。ND协议对应于IPv4的几个协议：ARP，ICMP，RDISC，ICMP重定向。</p><p>    - 简化</p><p>        - IPv6允许使用两个冒号来表示连续的16位零字段，但一个ipv6地址只允许用两个冒号一次。（只要是连续的零位段，无论几个都可以用：：表示）</p><p>        - 其他零字段（非连续单独存在）可以表示为单个零</p><p>        - 可以省略字段中的前导零。eg:0015 简化后 15</p><p>    - IPv6前缀</p><p>        - 前缀长度用CIDR表示法声明：即在地址末尾有一个斜杠，斜杠后面以位为单位的前缀长度。eg:2001:1156:ac54::&#x2F;48(站点前缀)</p><p>    - 地址种类</p><p>        - 单播地址</p><p>            - 全局单播地址</p><p>                - 在Internet中保持全局唯一。</p><p>            - 本地单播地址</p><p>                - 本地网络中使用的单播地址（类似于IPV4中的私有地址）</p><p>            - 过渡型全局单播地址</p><p>                - 为进ipv4-ipv6的过渡，这种类型的IPv6地址便于借助现有的IPv4网络隧道传送IPv6包。（2002：：&#x2F;16）</p><p>            - 特殊地址</p><p>                - 1)未指定地址： ：：&#x2F;128 2)回环地址： ：：&#x2F;128 用于验证网络通信</p><p>        - 多播地址</p><p>            - 多播地址用于表示一组通常位于不同节点上的接口，发送到多播地址的的地质报将传递到多播组的所有成员。（多播地址不能作为IPv6数据包的源地址）</p><p>        - 任播地址</p><p>            - 与多播地址相似，用于标识一组通常位于不同节点上的接口，发送到任播地址的包将传递到任波组中物理位置最近发送者的成员节点（同样不能作为IPv6数据包的源地址）</p><p>    - 与IPv4</p><ul><li><p>交换机</p></li><li><p>IPv4</p></li></ul><p>    - 组成</p><p>        - 网络地址（网络号）：用于标识某一个网段是的地址（主机号全0不可用）{特殊地址：广播地址——主机号全1也不可用}</p><p>        - 子网地址：将一个网络划分为多个子网</p><p>        - 主机地址（主机号）：用于表示某一台具体网络设备的地址</p><p>        - 子网掩码：用于区分网络号和主机号</p><p>    - 分类</p><p>        - A类</p><p>            - 网络|主机|主机|主机</p><p>            - 1.0.0.1~127.255.255.254</p><p>        - B类</p><p>            - 网络|网络|主机|主机</p><p>            - 128.0.0.1~191.255.255.255.254</p><p>        - C类</p><p>            - 网络|主机|主机|主机</p><p>            - 192.0.0.1~223.255.255.254</p><p>        - D类</p><p>            - 保留使用，二进制开头为 1110</p><p>        - E类</p><p>            - 保留使用，二进制开头为 1111</p><p>        - 私有地址：因为IPv4地址逐渐不够用，转而用部分地址转为私有地址在局域网内使用：</p><p>            - A类私有地址：0.0.0.0到127.255.255.255 127.0.0.0到127.255.255.255是保留地址，用做循环测试使用。</p><p>            - B类私有地址：172.16.0.0到172.31.255.255</p><p>            - C类私有地址：192.0.0.0到223.255.255.255</p><ul><li>动态路由</li></ul><p>    - RIP</p><p>    - OSPF</p><p>        - 概述</p><p>            - 工作于IP层之上，IP协议号为89.以组播地址224.0.0.5发送协议包</p><p>            - 基本思想：每个路由器将其已知的链路状态告诉邻接路由器，收敛以后，网络上每个路由器对全网的链路状态有相同的认识。然后根据每个路由器对全网链路的状态，独立计算路由。</p><p>        - OSPF优点</p><p>            - 使用SPF算法，提供无环路拓扑</p><p>            - 基于开放标准，适用于大规模网络。</p><p>            - 属于无类路由协议，支持VLSM和CIDR</p><p>            - 触发更新和增量更新，收敛速度较快</p><p>        - OSPF的缺点</p><p>            - 需要额外的CPU处理SPF算法啊</p><p>            - 需要更多的内存维持邻居，拓扑和路由表</p><p>            - 对于大型网络的设计要求更加严格</p><p>            - 配置相对复杂，排错比较困难</p><p>        - OSPF协议工作过程</p><p>            - 1.发现邻居： 1.通过组播hello包 2.通过同一个广播域内的接口建立一组邻居关系 3.所有邻居都可能跟自己交换链路信息</p><p>            - 2.建立邻接关系 ： 1.只有建立邻接关系的路由器之间才会交换链路状态信息。 2.同一个广播域的接口中选举DR和BDR，网络内所有路由器只与DR和BDR建立邻接关系。 3.广播型网络中会选DR和BDR，P2P中则不会。（简单来说就是点对点不会，大家伙都连接就会）</p><p>                - DR(Designated Router)[指定路由器] BDR(Backup Designated Router)备用指定路由器</p><p>            - 3.交换链路状态信息： 1.每台设备都有一个LSDB(Link State Database)[链路状态数据库&lt;个人理解:这不就是路由表吗&gt;] 2.LSDB中每一条就是LSA(Link State Advertisement)[链路状态公告]：用于描述链路状态信息，例如描述路由器的ID，网段，开销等。</p><p>            - 4.传递链路状态信息： 1.触发更新&#x2F;每隔30分钟更新一次 如果网络发生变化，立刻向邻居发送信息 2.增量更新机智，只发送邻居需要的LSA 3.收敛之后，区域内所有路由器具有相同的LSDB。(LSDB能体现全区域的拓扑结构)</p><p>            - 5.计算路由： 每台路由器 根据自己的LSDB独立计算路由</p><p>        - 分区域管理</p><p>            - 概念</p><p>                - 不同网络区域之间的连接是通过ABR(Area Border Router)[边界路由器]连接</p><p>                - 同一个区域内的路由器才会建立令居关系，交换LSA。收敛之后，同一个区域内的所有设备都用相同的LSDB。而不同区域内，都由ABR直接转发路由</p><p>            - 结构</p><p>                - 每个区域都由自己的ID，ID为32位二进制，可以表示为一个十进制数，或用点分十进制表示。(0.0.0.1)</p><p>                - 区域内舍友一个骨干区域——区域0。</p><p>                    - 非骨干区域之间不能直接通信，而要通过骨干区转发来防止产生路由环路。如果网络中有多个OSPF区域，必然有一个区域为区域0（个人感觉有点像生成树协议）</p><p>            - 数据结构</p><p>                - OSPF拥有三张表，分别是邻居表(Neighbor TAble),链路状态数据表(Link-State Database Table)和路由表</p><p>        - 配置与命令</p><p>            - 启动OSPF进程： (config)# router ospf [进程号(1~65535)] (config-router)# router-id [router-id] x.x.x.x&#x2F;&#x2F;设置路由器的ID (config-router)# network 192.168.0.228 0.0.0.3 area 0 重启OSFP进程： (config)# reset ospf [process-id] 配置OSPF区域： (config-ospf-100)area area-id 在指定接口上启动OSPF： 显示相关信息： # show ip protocol # show ip ospf # show ip ospf interface # show ip ospf neighbor # show ip route ospf</p><p>                - 通配符掩码：子网掩码的反码 eg.子网掩码255.255.255.255.0，对应通配符掩码：0.0.0.255</p><p>                - 设置对某一特定范围的子网进行汇总 Router(config-router)# area (区域号) range 子网范围掩码</p><p>            - OSPFv3(IPv6 OSPF)</p><p>                - OSPFv3与OSPFv2的原理相同，但是进行配置时，必须到相应接口下明确指定，并不像OSPFv2那样在进程下通过network来发布。</p><p>                - 启用IPv6路由： # ipv6 unicast-routing 启用OSPFv3进程 # ipv6 router ospf (进程号) 指定路由器ID (con-rtr)# router-id a.b.c.d 在接口上放进OSPFv3进程 (if)# ipv6 ospf (进程号) area (区域号)</p><p>        - 路由器ID</p><p>            - 概念</p><p>                - 路由器ID(Router-ID)是指路由器的标识符，它适用于在网络中标识路由器的身份。可以在OSPF路由进程中手工指定；</p><p>            - 指定路由器ID</p><p>                - (config-router)# router-id <em>.</em>.<em>.</em> OSPF在计算最佳路径时，需要使用ID号标识路由器。OSPF确定路由器ID遵循如下顺序：</p><p>                    - 最优先的是OSPF进程中使用命令router-id手工指定</p><p>                    - 如果没有手工指定，路由器默认选择会还接口中最大的IP地址作为路由器ID</p><p>                    - 如果没有换回地址，路由器选择所有激活的物理接口中最大的IP地址作为路由器ID</p><p>        - OSPF度量值计算</p><p>            - OSPF度量值Cost的计算方法为：Cost&#x3D;108&#x2F;（出接口参考带宽），出口参考带宽的单位为bit&#x2F;s。</p><p>        - OSPF.pkt</p><ul><li>NAT</li></ul><p>    - 技术原理</p><p>        - 网络地址转换（Network Address Translation[NAT]）通过某些特定方式能将内部地址翻译成外部合法全局地址，使得不具合法的IP地址的用户可以访问到外地Internet。这些特定方式有三种，分别为静态地址转换，动态地址转换，和端口映射。</p><p>        - 对于解决IP地址紧张的问题，IETF的建议是企业组网时不必申请共有地址，可以采用下列IP私有地址，需要访问公网Internet时采用NAT网关来掩蔽私有地址。</p><p>        - 设置NAT功能的路由器至少有一个内部端口（inside）以及一个外部（outside）端口。内部端口连接本地用户，使用内部本地IP地址。外部端口连接外部网络。内外部端口可以是路由器上的任意端口。</p><p>    - 静态地址转换</p><p>        - 原理：将内部本地地址与内部和发地址进行一对一的转换，且需要指定和哪个合法地址进行转换。如果内部网络有E-mail服务器或FTP服务器等可以为外部用户公用的服务，这些服务器的IP地址必须采用静态地址转换，以便外部用户可以使用这些服务。</p><p>        - 命令：</p><p>            - 定义静态地址转换： # (config) ip nat inside source static (内部局部地址[本地地址])(内部全局地址[公网地址]) eg. ip nat inside source tatic 192.168.1.2 61.139.10.33</p><p>            - 将S1&#x2F;0 定义为NAT 外部接口 # (config)int s1&#x2F;0 # (config-if)ip nat outside</p><p>            - 将fa0&#x2F;0 定义为NAT 外部接口 # (config)int fa0&#x2F;0 # (config-if)ip nat inside</p><p>    - 动态地址转换</p><p>        - 原理：将内部本地地址与内部和发地址进行一对一的转换，在转换时，从内部合法地址范围中动态地址池选择一个未使用的地址与内部本地地址进行转换。当地址池内的内部IP地址全部使用完毕时，后续的NAT盛情将失败。这种方式适用于申请得到较多合法地址的场合。</p><p>            - 定义IP地址池 # (config) ip nat pool (地址池名称) 起始IP地址 终止IP地址 netmask 子网掩码 eg.ip nat pool dzcpool 61.139.10.33 61.139.10.46 netmask 255.255.255.240</p><p>            - 配置动态NAT映射 # (config)ip nat inside source list (标号) permit 源地址 通配符 eg.ip nat inside source list 1 dzcpool</p><p>            - 指定被转换的源地址 # (config)access-list (标号) permit 源地址 通配符（子网掩码反码） eg.access-list 1 permit 192.168.1.0 0.0.0.255</p><p>            - 定义外部接口 # (config)int s1&#x2F;0 # (config-if)# ip nat outside</p><p>            - 定义内部接口 # (config)int fa0&#x2F;0 # (config-if)ip nat inside</p><p>    - 端口映射</p><p>        - 原理端口映射首先是一种动态地址转换，但是他可以允许多个内部本地地址共用一个或少数内部合法地址。当只申请到少量IP地址，但却经常同时有多个用户上外部网络时，这种转换时很有用的。由于是通过端口号来区分不同的内部连接因而名为端口映射。</p><p>            - 指定被转换的源网段 # (config)access-list 1 permit 192.168.1.0 0.0.0.255 (定义标准访问列表1允许192.168.1.0网段的所有主机)</p><p>            - 采用端口映射将本地地址转换为某接口上的内部全局地址 # (config)ip nat inside source list (访问列表号) interface (外部接口名) overload eg.ip nat inside source list 1 interface s1&#x2F;0 overload</p><p>            - 定义外部接口 # (config)int s1&#x2F;0 # (config-if)# ip nat outside</p><p>            - 定义内部接口 # (config)int fa0&#x2F;0 # (config-if)ip nat inside</p><ul><li>密码</li></ul><p>    - 特权登录密码</p><p>        - 设置进入特权模式的密码 (config)# enable password ***（明文密码） (confg)# enable secret *****(密文密码)</p><p>    - console口密码</p><p>        - 进入console口 # (config)line console 0</p><p>        - 设置密码 # （config-line）password **** # （config-line）login</p><p>        - 设置进入特权模式的密码 (config)# enable password ***（明文密码） (confg)# enable secret *****(密文密码)</p><p>    - Telnet密码</p><p>        - 进入线路模式 # （config）line vty 0 4</p><p>        - 开启telnet # (config-line)transport input telnet</p><p>        - 设置Telnet密码 # （config-line）passwrod **** # （config-line）login</p><p>        - 设置一个特权密码 # （config）enable password *****</p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机相关 </tag>
            
            <tag> 网络设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略路由PBR</title>
      <link href="/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1/"/>
      <url>/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>tag:<br>#计算机相关<br>#网络设备<br>#策略路由</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>策略路由(PBR, Policy-Based Routing) 是一种比基于目的地址进行路由转发更加灵活的数据包路由转发机制。路由器将通过路由图决定如何队需要路由的数据包进行处理，路由图决定了一个数据包的下一跳转发路由器。</strong></p><p><strong>策略路由可以根据IP&#x2F;IPv6报文</strong>&#x3D;&#x3D;<strong>源地址，目的地址，端口，报文长度等内容灵活进行路由选择</strong>&#x3D;&#x3D;</p><p><strong>目的地址路由：一种根据路由的目的地址来进行策略实施的路由<br>源地址路由：根据源地址来进行策略实施</strong></p><p><strong>策略路由比所有路由的级别都要高，包括直连路由</strong></p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>设置策略路由之前需要配置ACL，将源地址的流量匹配出来.</p><p>配置策略路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">R1(config)#route-map 路由图名称 primit 编号</span><br><span class="line">//创建路由表并命名编号</span><br><span class="line">R1(config-route-map)#match ip address ACL 编号</span><br><span class="line">//关联ACL的ip 地址</span><br><span class="line">R1(config-route-map)#set ip next-hop 下一跳IP地址</span><br><span class="line">//符合ACL表的ip 地址经过该路由器之后转发到下一跳IP地址</span><br><span class="line"></span><br><span class="line">//将策略路由应用到接口</span><br><span class="line">R1(config)#int gi0/0</span><br><span class="line">R1(config-if)#ip policy route map 路由图名称</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>**route-map的匹配顺序从上往下匹配，匹配到策略路由之后，按匹配的策略路由转发数据，不会继续往下匹配</li><li>**route-map最后有一条deny所有语句，对于没有匹配到策略路由的流量，不会吧内网的流量丢弃，而是做正常的ip路由转发</li><li>**set ip next-hop 可以设置下一跳IP地址，也可以设为数据包的出接口</li><li><strong>策略路由一定要应用到数据包的in 方向接口。</strong> 因为到out接口的时候已经发出去了，不会生效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机相关 </tag>
            
            <tag> 网络设备 </tag>
            
            <tag> 策略路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VRRP</title>
      <link href="/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/VRRP/"/>
      <url>/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/VRRP/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>**VRRP (Virtual Router REdindeancy Protocol– 虚拟路由冗余协议)<br>作用是它的设计目标是支持特定情况下IP数据流量失败转移不会引起混乱，允许主机使用单路由器，以及即使在实际第一跳路由器使用失败的情形下仍能够维护路由器间的连通性。</p><blockquote><p>简单来说就是做一个虚拟的网关，两个或多个物理上的网关。所有的物理网关都是虚拟网关的备选，这样路由器突然坏掉也不会断网。</p></blockquote><h1 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h1><h2 id="虚拟路由器"><a href="#虚拟路由器" class="headerlink" title="虚拟路由器"></a>虚拟路由器</h2><p>由一个Master路由器和多个Backup路由器组成。主机将虚拟路由器当成默认网关。</p><h2 id="VRID"><a href="#VRID" class="headerlink" title="VRID"></a>VRID</h2><p>虚拟路由器的表示。具有相同VRID的一组路由器构成一个虚拟路由器。</p><h2 id="Master路由器"><a href="#Master路由器" class="headerlink" title="Master路由器"></a>Master路由器</h2><p>虚拟路由器中承担报文转发任务的路由器</p><h2 id="Backup路由器"><a href="#Backup路由器" class="headerlink" title="Backup路由器"></a>Backup路由器</h2><p>Master路由器 出现故障时，能够代替Master路由器工作的路由器。</p><h2 id="虚拟IP地址"><a href="#虚拟IP地址" class="headerlink" title="虚拟IP地址"></a>虚拟IP地址</h2><p>虚拟路由器的IP地址。一个虚拟路由器可以拥有一个或者多个IP地址。</p><h2 id="IP地址拥有者"><a href="#IP地址拥有者" class="headerlink" title="IP地址拥有者"></a>IP地址拥有者</h2><p>端口IP地址与虚拟IP地址相同的路由器称为IP地址拥有者</p><h2 id="虚拟MAC地址"><a href="#虚拟MAC地址" class="headerlink" title="虚拟MAC地址"></a>虚拟MAC地址</h2><p>一个虚拟路由器拥有一个虚拟MAC地址。虚拟MAC地址的格式为<br><code>00-00-5E-00-01-&#123;VRID&#125;</code></p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>VRRP根据优先级确定虚拟路由器中每个路由器的地位。</p><h2 id="非抢占方式"><a href="#非抢占方式" class="headerlink" title="非抢占方式"></a>非抢占方式</h2><p>若Backup路由器工作在非抢占方式下，只要Master路由器没有故障，Backup路由器即使随后被分配到了更高的优先级，也不会称为Maste路由器。</p><h2 id="抢占方式"><a href="#抢占方式" class="headerlink" title="抢占方式"></a>抢占方式</h2><p>不多废话，路由器根据优先级抢占成为Master路由器。</p><h1 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h1>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机相关 </tag>
            
            <tag> 网络设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPPoE&amp;PPP</title>
      <link href="/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/PPPoe&amp;PPP/"/>
      <url>/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/PPPoe&amp;PPP/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>PPP - 即为 点对点协议（Point-point Protocol）</strong><br>PPP适用于同步或者异步串行线路的协议，支持专线与拨号连接。PPP封装的串行线路支持&#x3D;&#x3D;PAP（Password Authentication Protocol —口令验证协议）&#x3D;&#x3D; 和 &#x3D;&#x3D;CHAP（Challenge-Handeshake Authentication Protocol —-挑战握手验证协议）&#x3D;&#x3D; 安全性认证。使用这两个东西认证时，每个路由器通过名字来识别，并使用密码来防止未经授权的访问。<br>家庭拨号上网就是通过PPP在用户端和运营商的接入服务器之间建立通信链路来实现的。</p><blockquote><p><em><strong>没有PPP一样可以实现网络通信，PPP并不是一种连接用的协议，而是一种认证手法可以让运营商更好的收费。用户用金钱向运营商获取授权，然后才可以使用运营商提供的链路上网。</strong></em></p></blockquote><h2 id="PPPoe"><a href="#PPPoe" class="headerlink" title="PPPoe"></a>PPPoe</h2><p>&#x3D;&#x3D;利用 ethernet 资源，在以太网上运行PPP来进行用户认证介入的方式成为PPPoe（PPP over Ethernet）。&#x3D;&#x3D;<br>PPPoe既保护了用户方的以太网资源，又完成了ADSL（非堆成数据用户环线-现已淘汰）的介入要求，说目前ADSL介入方式中应用最广泛的技术标准。</p><h2 id="PAP"><a href="#PAP" class="headerlink" title="PAP"></a>PAP</h2><p>PAP 是两种PPP认证协议中最简单的一种，也最不安全。<br>在认证时，PAP经历两次握手过程，且以铭文的方式将用户名和密码发送到接收站。接收站将其与存储在本地的信息比较，如果有匹配项目，则会回应接受。反之，发送一条拒绝消息。——明文传输非常不安全。</p><p>PAP的配置是直接的，确定哪边作为客户端（发送用户名和密码），哪边作为服务端（验证信息）。</p><h2 id="CHAP"><a href="#CHAP" class="headerlink" title="CHAP"></a>CHAP</h2><p>CHAP 使用机遇消息摘要5（MD5）散列算法的单向散列函数来对密码进行处理。（&#x3D;&#x3D;简单来说就是一种无法反向还原的加密方式&#x3D;&#x3D;）</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>&#x3D;&#x3D;CHAP使用三次握手过程来执行认证&#x3D;&#x3D;。首先，发送站将它的用户名发送到接收站。接收站返回一个&#x3D;&#x3D;挑战&#x3D;&#x3D;——一个接收站生成的随机值。<br>然后两端取出发送站的名称，匹配密码与挑战，让他们通过MD5散列函数进行运算。随后，发送站将函数运行结果去除发送到接收站。接收站吧这个值与自己产生的散列输出进行比较。如果两个值匹配，&#x3D;&#x3D;发送站使用的密码必须与接收站使用的密码相同，这样接收站会运行该链接。&#x3D;&#x3D;</p><blockquote><p>简单来说，两个人打了个招呼之后一起做数学题，做出来了发现答案一样就建立了深厚的感情。</p></blockquote><h2 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h2><p><strong>配置当前路由器的名字和口令</strong><br>因为需要传输这两个玩意作为认证凭证，所哟需要设置这个。<br><code>Router(config)#host name [这里写名字]</code><br><code>Router(config)#enable secret [这里写密码]</code></p><p><strong>站当前路由器上记录对端路由器的名字和口令</strong><br>毕竟知道对方的名字才能辨别对方嘛<br><code>Router(config)#username [对端路由器名字] password [对端路由器密码]</code></p><p><strong>封装协议</strong><br><code>Router(config-if)#encapsulation ppp</code><br>注意，这里是进入与目标路由器相连的接口上进行封装。<br>且PPP是针对串口的协议，请记得使用对应的接口和线。</p><p><strong>指定PPP用户验证协议配置认证方式</strong><br><code>Router(config-if)#ppp authentication chap|ppp</code></p><p><strong>查看路由器端口封装协议</strong><br><code>Roter# show interface [串口名称]</code><br>如果这里出现 <code>closed:IPCP,CDPCP</code>等字样，意味着PPP没有配置正确。</p><p>%%  %%</p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机相关 </tag>
            
            <tag> 网络设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>边界网关协议BGP</title>
      <link href="/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/BGP/"/>
      <url>/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/BGP/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>BGP (Border Gateway Protocol) 边界网关协议。是一种不同自治系统的路由设备之间进行通信的外部网关协议（Exterior Gateway Protocol EGP）其主要功能是在不同的自治系统（Autonomous Systems AS）之间交换网络可达信息，并通过协议自身机制来消除路由环路。BGP使用TCP协议作为传输协议，通过TCP协议的可靠传输机制保证了BGP传输可靠性。</strong><br>运行BGP协议的Router称为BGP Speaker，建立了BGP会话连接的BGP Speakers之间被称作对等体。（BGP Peers）</p><p>BGP Speeker 之间建立对等体的模式有两种 ：IBGP和EBGP。</p><p>&#x3D;&#x3D;<strong>IBGP:指在相同AS内建立BGP链接。完成路由信息在本AS内的传递。AS号一致<br>EBGP：在不同AS之间建立BGP链接。完成不同AS之间的路由信息交换。AS号不一致</strong>&#x3D;&#x3D;</p><h2 id="更新源地址"><a href="#更新源地址" class="headerlink" title="更新源地址"></a>更新源地址</h2><p>EBGP邻居在AS边界，建议采用直连接口做更新源地址，直连可达，就无需IGP协议再打通更新源地址之间的路由。</p><p>IBGP邻居在AS内部，建议采用loopback地址做为更新源地址，loopback地址可靠（不会因为物理线路down掉，导致bgp邻居动荡），AS内部一般都有IGP协议打通更新源地址的路由。</p><p>&#x3D;&#x3D;IBGP存在水平分割，从IBGP邻居学习来的路由，不会再传递给其他的IBGP邻居（会传递给EBGP邻居）。&#x3D;&#x3D;</p><h1 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h1>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机相关 </tag>
            
            <tag> 网络设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问控制列表</title>
      <link href="/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/ACL/"/>
      <url>/2025/04/17/web/%E7%BD%91%E8%B7%AF%E8%AE%BE%E5%A4%87/ACL/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><hr><p><strong>访问控制列表–ACL（Access Control List）是应用在路由器接口的指令列表，这些指令列表用来告诉路由器，哪些数据包可以接收，哪些数据包需要拒绝。它的主要任务是保证网络资源不被非法使用和访问，是保证网络安全最重要的核心策略之一。</strong></p><blockquote><p>&#x3D;&#x3D;<em>请注意，路由器本身发送的数据不受ACL控制</em>&#x3D;&#x3D;</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><hr><p>**ACL使用包过滤技术，在路由器上读取OSI七层 模型的第三层（网络层）及第四层（传输层）<br>包头中的信息。如：源地址，目的地址，源端口，目的端口，根据预先定义好的规则，对包进行过滤，从而达到访问控制的目的。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><hr><ol><li>ACL可以限制网络流量，提高网络性能</li><li>ACL是提供网络安全访问的基本手段</li><li>ACL可以在路由器端口处决定哪种类型的通信流量被转发或阻塞</li></ol><h2 id="ACL应用原则以及执行过程"><a href="#ACL应用原则以及执行过程" class="headerlink" title="ACL应用原则以及执行过程"></a>ACL应用原则以及执行过程</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><hr><p><strong>3P原则:每种协议(per protocol),每个方向(per direction),每个端口(per interface)配置一个ACL</strong></p><p><strong>一个&#x3D;&#x3D;标准ACL&#x3D;&#x3D;匹配IP包中的源地址或源地址中的一部分，可对匹配的包采取拒绝或允许两个操作，且标准访问控制列表要尽量靠近目的端。</strong></p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><hr><p>一个端口执行哪条ACL，这需要按照列表中的条件语句执行顺序来判断。如果一个数据包的报头跟表中某个判断语句相匹配，name后面的语句就将忽略，不再检查</p><blockquote><p>**省流：switch 的每个case里都有一个break;</p></blockquote><p>数据包只有在第一个判断条件不匹配时，它才被交给ACL中下一个条件判断语句进行比较。如果匹配（假设允许发送），则不管是第一条还是最后一条语句，数据都会立即发送到目的接口。如果所有的ACL判断语句都检测完毕，仍然没有匹配的语句，则该数据包将视为拒绝而被丢弃。（也就是默认最后一条语句为拒绝发送）</p><blockquote><p>**省流： default false;</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>目前主要有三种ACL：</p><ol><li>标准ACL<br> <strong>标准ACL使用1-99以及1300-1999之间的数字作为表号，是基于&#x3D;&#x3D;源IP地址&#x3D;&#x3D;过滤数据包</strong></li><li>扩展ACL<br> **扩展ACL使用100-199以及2000-2699之间的数字作为表号，可以基于&#x3D;&#x3D;源IP地址，目的IP地址，指定协议，端口和标志来过滤数据包&#x3D;&#x3D;</li><li>命名ACL<br> 命名ACL是以列表名称代替编号来定义ACL，同样包括标准和扩展两种列表。在使用命名访问控制列表时，要求路由器IOS是11.2以上的版本，并且不能以同一个名字命名多个ACL，不同类型的ACL也不能相同名字<blockquote><p>**省流：primary_key unique</p></blockquote></li><li>时间ACL<br> 从IOS12.0开始，思科路由器新增加了一种基于时间的访问系统列表。可以根据一天中不同时间，或是日期，来控制网络数据包转发</li></ol><h2 id="定义规范"><a href="#定义规范" class="headerlink" title="定义规范"></a>定义规范</h2><ol><li>ACL是通过表号或者表名区别的</li><li>一个ACL的配置是<a href="#%E5%8E%9F%E5%88%99">3P</a>的</li><li>ACL的雨具顺序决定了数据包的控制顺序</li><li>最有限制性的雨具应该放在ACL语句 的首行</li><li>在将ACL应用到接口之前，一定要先建立ACL</li><li>在ACL的最后，有一条隐含“全部拒绝”的命令，所以在ACL是至少有一条“允许”的语句。</li><li>ACL职能过滤穿过路由器的数据流量，不能过滤本路由器上发出的数据包</li><li>在路由器进行选择以前，应用在接口进入方向的ACL起作用</li><li>在路由器选择决定以后，用在交界口离开的方向的ACL起作用</li></ol><h2 id="标准ACL配置命令"><a href="#标准ACL配置命令" class="headerlink" title="&#x3D;&#x3D;标准ACL配置命令&#x3D;&#x3D;"></a>&#x3D;&#x3D;标准ACL配置命令&#x3D;&#x3D;</h2><h3 id="创建ACL"><a href="#创建ACL" class="headerlink" title="创建ACL"></a>创建ACL</h3><p>Router(config)#access-list access-list&#x3D;&#x3D;[number]&#x3D;&#x3D; &#x3D;&#x3D;permit | deny&#x3D;&#x3D; &#x3D;&#x3D;source-ip-address&#x3D;&#x3D; &#x3D;&#x3D;wildcard-mask&#x3D;&#x3D;<br>                            列表编号允许或拒绝源IP地址子网掩码反码<br>eg.&#96;Rouuter(config)#access-list access-list 1 permit 192.168.1.0 0.0.0.255</p><h3 id="将ACL应用于接口"><a href="#将ACL应用于接口" class="headerlink" title="将ACL应用于接口"></a>将ACL应用于接口</h3><p>Router(config-if)#ip access-group access-list-number in | out<br>eg.<code>Router(config-if)#ip access-group 1 in</code></p><h3 id="删除已建立的标准ACL"><a href="#删除已建立的标准ACL" class="headerlink" title="删除已建立的标准ACL"></a>删除已建立的标准ACL</h3><p>Router(config-if)#ip access-group access-list-number in | out<br>eg. ‘Router(config-if)#ip access-group 1 in’</p><blockquote><p>对于标准ACL，不能删除单条ACL语句，只能够删除整个ACL</p></blockquote><h2 id="扩展ACL配置命令"><a href="#扩展ACL配置命令" class="headerlink" title="扩展ACL配置命令"></a>扩展ACL配置命令</h2><h3 id="创建ACL-1"><a href="#创建ACL-1" class="headerlink" title="创建ACL"></a>创建ACL</h3><blockquote><p>Router(config)#access-list <em>access-list-number</em><sup>1</sup><em>permit| deny</em><sup>2</sup> <em>protocol</em> <sup>3</sup>source <em>source-wildcard</em> <em>destion<sup>4</sup> destion-wildcard</em>  <sup>5</sup><em>operator operan</em><sup>6</sup></p></blockquote><h3 id="将ACL应用到特定的端口"><a href="#将ACL应用到特定的端口" class="headerlink" title="将ACL应用到特定的端口"></a>将ACL应用到特定的端口</h3><p><code>Router(config-if)#ip access-group access-list-number in | out</code></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><strong>eg.允许网络192.168.1.0&#x2F;24访问网络192.168.2.0&#x2F;24的&#x3D;&#x3D;IP流量通过&#x3D;&#x3D;，而拒绝其他任何流量，ACL配置命令如下：</strong><br> <code>Router(config)#access-list 101 permit ip 192.168.1.0 0.0.0.255 192.168.2.0 0.0.0.255</code><br><code>Router(config)#access-list 101 deny ip any any</code></p><p><strong>eg.拒绝网络192.168.1.0&#x2F;24&#x3D;&#x3D;访问FTP服务器192.168.2.2&#x2F;24的IP流量通过&#x3D;&#x3D;，而允许其他任何流量，ACL配置命令如下：</strong></p><p><code>Router(config)#access-list 101 deny tcp 192.168.1.0 0.0.0.255 host 192.168.2.2 eq 21 </code>Router(config)#access-list 101 permit ip any any</p><p><strong>eg.禁止网络192.168.1.0&#x2F;24中的&#x3D;&#x3D;主机ping通服务器&#x3D;&#x3D;192.168.2.2&#x2F;24，而允许其他任何流量，ACL配置命令如下：</strong></p><p><code>Router(config)#access-list 101 deny icmp 192.168.1.0 0.0.0.255 host 192.168.2.2 echo </code>Router(config)#access-list 101 permit ip any any</p><p><strong>eg.禁止A网段192.168.1.1-192.168.1.30访问B网段的主机192.168.2.200。</strong><br><code>Router(config)#access-list 100 deny ip 192.168.1.0 0.0.0.31 host 192.168.2.200</code><br><code>Router(config)#access-list 100 permit ip any any</code><br><code>Router(config)#int fa0/0</code><br><code>Router(config-if)#ip access-group 100 in</code></p><h2 id="命名ACL"><a href="#命名ACL" class="headerlink" title="命名ACL"></a>命名ACL</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>命名ACL是以列表名称代替列表编号来定义ACL，同意包括表尊和扩展两种列表。</strong><br><strong>命名ACL还可以被用来从某一特定的ACL中删除个别的控制条目，这样可以使网络管理员方便修改ACL</strong></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="命名ACL的创建"><a href="#命名ACL的创建" class="headerlink" title="命名ACL的创建"></a>命名ACL的创建</h4><p><code>Router(config)#ip access-list standard| extended access-list-name</code></p><ol><li>standard:创建标准的命名访问控制列表</li><li>extended:创建欧战的命名访问控制列表</li><li>access-list-name:命名访问控制列表的名字，可以是任意字母和数字的组合</li></ol><p><code>eg. Router(config)#ip access-list standard aa.</code></p><h4 id="标准命名ACL语法"><a href="#标准命名ACL语法" class="headerlink" title="标准命名ACL语法"></a>标准命名ACL语法</h4><p><code>Router (config-std-nacl)#[sequence-number] permit|deny source [source-wildcard]</code></p><p>eg.<br>将一条新添加的ACL加入到原有标准命名ACL的序列15的位置，内容为允许主机192.168.1.1&#x2F;24访问Internet<br>    <code>Router(config)#ip access-list standard test 1</code><br>    <code>Router(config-std-nacl)#15 permit host 192.168.1.1</code></p><h4 id="扩展命名ACL语法"><a href="#扩展命名ACL语法" class="headerlink" title="扩展命名ACL语法"></a>扩展命名ACL语法</h4><p><code>Route(config-ext-nacl)#[sequence-number] permit|deny protool source source-wildcard destination destination-wildcard [opeatro operan]</code></p><p>eg.<br>创建扩展命名ACL，内容为拒绝192.168.1.0&#x2F;24访问FTP服务器192.168.2.200&#x2F;24，允许其他主机访问。<br>    <code>Router(config)#ip access-list extender test2</code><br>    <code>Router(config-std-nacl)#deny tcp 192.168.1.0 0.0.0.255 host 192.168.2.200 eq 21</code><br>    <code>Router(config-std-nacl)#[ermit ip any any</code></p><p><strong>sequence-number</strong></p><p><strong>sequence-number</strong>:这个参数表明了配置ACL语句在命名ACL中所处的位置，默认情况下，第一条为10，第二条为20，以此类推。<br><strong>sequence-number</strong>可以很方便地将新添加的ACL语句插入到原有的ACL语句列表中指定的位置。&#x3D;&#x3D;如果不使用sequence-number参数，默认添加至ACL语句列表末尾并且序列号加10。&#x3D;&#x3D;</p><h4 id="删除已建立的命名ACL"><a href="#删除已建立的命名ACL" class="headerlink" title="删除已建立的命名ACL"></a>删除已建立的命名ACL</h4><p><code>Router(config)#no ip access-list standard| extended access-list-name</code><br><strong>如果要删除某一条ACL语句，可以使用“no sequence-number”或“no ACL”语句两种方式。</strong></p><h4 id="将命名ACL应用到接口"><a href="#将命名ACL应用到接口" class="headerlink" title="将命名ACL应用到接口"></a>将命名ACL应用到接口</h4><p><code>Route(config-if)#ip access-group access-list-name in|out</code></p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>题目：配置命名ACL，要求192.168.1.0&#x2F;24网段中除了192.168.1.4外的其他地址都不能访问服务器192.168.100.100，但其他网段的地址可以访问服务器192.168.100.100</p><p>PC（192.168.1.0&#x2F;24）–（.254|fa0&#x2F;0）Router（.254|fa0&#x2F;1）–Server（192.168.100.100&#x2F;24）<br><strong>配置命令如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#ip access-list extended kz</span><br><span class="line"></span><br><span class="line">Router(config-ext-nacl)#permit ip host 192.168.1.4 host 192.168.100.100</span><br><span class="line"></span><br><span class="line">Router(config-ext-nacl)#deny ip 192.168.1.0 0.0.0.255 host 192.168.100.100</span><br><span class="line"></span><br><span class="line">Router(config-ext-nacl)#permit ip any host 192.168.100.100</span><br><span class="line"></span><br><span class="line">Router(config-ext-nacl)#exit</span><br><span class="line"></span><br><span class="line">Router(config)#interface fa0/0</span><br><span class="line"></span><br><span class="line">Router(config-if)#ip access-group kz in</span><br></pre></td></tr></table></figure><p><strong>查看</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Router#show access-list</span><br><span class="line"></span><br><span class="line">Extended IP access list kz</span><br><span class="line"></span><br><span class="line">    10 permit ip host 192.168.1.4 host 192.168.100.100</span><br><span class="line"></span><br><span class="line">    20 deny ip 192.168.1.0 0.0.0.255 host 192.168.100.100</span><br><span class="line"></span><br><span class="line">    30 permit ip any host 192.168.100.100</span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><p>题目：.现变更访问服务器的ACL，不允许192.168.1.4的主机访问服务器，允许192.168.1.5的主机访问服务器。</p><p>ACL变更配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#ip access-list extended kz</span><br><span class="line"></span><br><span class="line">Router(config-ext-nacl)#no 10</span><br><span class="line"></span><br><span class="line">Router(config-ext-nacl)#11 permit ip host 192.168.1.5 host 192.168.100.100</span><br><span class="line"></span><br><span class="line">//注意：如果不指定序列号，则新添加的ACL被添加到列表的末尾。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机相关 </tag>
            
            <tag> 网络设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讯飞语音识别</title>
      <link href="/2025/04/17/web/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98/%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
      <url>/2025/04/17/web/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98/%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>#Android<br>#软件开发</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>实现语音识别和词汇的自动修正，可添加热词来加部分词语权重来达到修正的目的。</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>![[Pasted image 20241029193810.png]]<br>![[Pasted image 20241029193911.png]]</p><ul><li>Lib -外带的SDK包，用于调用API</li><li>resource -用于存放音频资源</li></ul><h2 id="包声明以及导入"><a href="#包声明以及导入" class="headerlink" title="包声明以及导入"></a>包声明以及导入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo; </span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson; </span><br><span class="line"><span class="keyword">import</span> com.google.gson.JsonObject; </span><br><span class="line"><span class="keyword">import</span> okhttp3.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Mac;</span><br><span class="line"><span class="keyword">import</span></span><br><span class="line">javax.crypto.spec.SecretKeySpec; </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream; </span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException; </span><br><span class="line"><span class="keyword">import</span> java.net.URL; </span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset; </span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat; </span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><ul><li>导入了一系列用于处理<a href="####Json">JSON</a>（Gson和JsonObject）,</li><li>进行HTTP请求<a href="####OKHttp3">OKHttp3，Request，Response，WebSocket和 WebSockertLisnner）</a></li><li>加密（Mac和SecretKeySpec）,</li><li>文件输入流（FileInputStream）,</li><li>处理异常（FileNotFoundException,IOException）,</li><li><a href="####URL">处理URL（URL）</a></li><li>处理字符集（Charest）和</li><li><a href="####%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96">日期格式化（SimleDataFormat）的类</a></li></ul><h4 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h4><p>JSON <em>JavaScript Object Natation</em> 是一种轻量级的数据交换格式。<br>JSON采用完全独立于编程语言的文本格式，使用键值对的方式来表示数据对象，数组，字符串，数字，布尔值和null值等等。</p><p><strong>Gson</strong>是Google提供的一个JAVA库，用于在Java对象和Json数据之间进行转换</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>加入我们有一个简单的java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age; </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.name = name; </span><br><span class="line"> <span class="built_in">this</span>.age = age; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 省略 getter 和 setter 方法 &#125;</span></span><br></pre></td></tr></table></figure><p>使用Gson将其转换为Json字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> gson.toJson(person);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure><p>输出结果为：<br><code>&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:&quot;30&quot;&#125;</code></p><p><strong>也可以将JSON字符串转化为JAVA对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;Bob\&quot;,\&quot;age\&quot;:25&#125;&quot;</span>; </span><br><span class="line"><span class="type">Person</span> <span class="variable">personFromJson</span> <span class="operator">=</span> gson.fromJson(jsonStr, Person.class);</span><br><span class="line">System.out.println(personFromJson.getName() + <span class="string">&quot; &quot;</span> + personFromJson.getAge());</span><br></pre></td></tr></table></figure><p>输出结果为：<code>Bob 25</code></p><blockquote><p>&#x3D;&#x3D;<strong>个人理解：感觉像xml java版</strong>&#x3D;&#x3D;</p></blockquote><h4 id="OKHttp3"><a href="#OKHttp3" class="headerlink" title="OKHttp3"></a>OKHttp3</h4><p><strong>概念很多，我不多说。主要就是用来访问http客户端。</strong><br>后面紧跟着的一大堆全是用来访问http的，建立链接，发送请求，发送数据帧一套丝滑小连招。</p><p>&#x3D;&#x3D;WebSocket:实现客户端与服务器之间的双向通信，双方可以同时发送和接收数据，不像Http请求那样单向的&#x3D;&#x3D;</p><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><p><strong>例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat; </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatExample</span> &#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Date</span> <span class="variable">currentDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> sdf.format(currentDate); System.out.println(formattedDate);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以根据需求选择日期和时间的格式 如–yyyy-MM-dd</strong></p><p><strong>把字符串解析为Date对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line">     <span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatExample</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">             <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> </span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="type">Date</span> <span class="variable">parsedDate</span> <span class="operator">=</span> </span><br><span class="line">                 sdf.parse(<span class="string">&quot;2024-10-29 12:30:00&quot;</span>);</span><br><span class="line">                 System.out.println(parsedDate);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>java.net.URL类主要用于表示统一资源定位符(<em>Uniform Resource Locator</em>),<br>可用于访问网络上的各种资源</p><h2 id="public-class-主类与定义常量"><a href="#public-class-主类与定义常量" class="headerlink" title="public class 主类与定义常量"></a>public class 主类与定义常量</h2><h3 id="WebIATWS"><a href="#WebIATWS" class="headerlink" title="WebIATWS"></a>WebIATWS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebIATWS</span> <span class="keyword">extends</span> <span class="title class_">WebSocketListener</span> &#123; <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>继承WebSockertListner,处理连接事件。<br>与讯飞建立双向的链接</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">hostUrl</span> <span class="operator">=</span> <span class="string">&quot;https://iat-api.xfyun.cn/v2/iat&quot;</span>;</span><br><span class="line">    <span class="comment">// private static final String hostUrl = &quot;https://iat-niche-api.xfyun.cn/v2/iat&quot;;//小语种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">appid</span> <span class="operator">=</span> <span class="string">&quot;4ba8d377&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">apiSecret</span> <span class="operator">=</span> <span class="string">&quot;ZDZlZjcxMzgwMGY3OWViODBjMjljMjcz&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">apiKey</span> <span class="operator">=</span> <span class="string">&quot;e384eed4e15ff580f7af2dc49fd9d062&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="string">&quot;iat_ws_java_demo\\resource\\iat\\16k_10.pcm&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">StatusFirstFrame</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">StatusContinueFrame</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">StatusLastFrame</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Gson</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="type">Decoder</span> <span class="variable">decoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Decoder</span>();</span><br><span class="line">    <span class="comment">// 开始时间  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Date</span> <span class="variable">dateBegin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();  </span><br><span class="line"><span class="comment">// 结束时间  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Date</span> <span class="variable">dateEnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span></span><br><span class="line"> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><hr><ul><li>**hostUrl:指定了讯飞听写的URL（直接理解为访问对面服务器）</li><li>**appid,apiSecret,apiKey：API使用凭证</li><li>**File：用字符串储存文件名</li><li>**json:用于JSON的序列化和反序列化</li><li>** &#x3D;&#x3D;<a href="#####%E4%B8%AD%E9%97%B4%E5%B8%A7">decoder</a>&#x3D;&#x3D;:用于解析服务器返回的识别结果</li><li>**dataBegin和dataEnd:用于记录开始和结束时间</li><li><strong>sdf:格式化时间</strong></li></ul><h2 id="onOpen"><a href="#onOpen" class="headerlink" title="onOpen"></a>onOpen</h2><h4 id="onOpen请求服务"><a href="#onOpen请求服务" class="headerlink" title="onOpen请求服务"></a>onOpen请求服务</h4><p>**重写onOpen方法，接收服务器响应参数<br>连接成功后开始发送数据<br>定义帧的大小，以字节 <em>byte</em> 为单位<br>intervel -间距 以毫秒为单位<br>status-状态 初始化为0<br>**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(WebSocket webSocket, Response response)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.onOpen(webSocket, response);  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;  </span><br><span class="line">        <span class="comment">//连接成功，开始发送数据  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">frameSize</span> <span class="operator">=</span> <span class="number">1280</span>; </span><br><span class="line">        <span class="comment">//每一帧音频的大小,建议每 40ms 发送 122B        </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">intervel</span> <span class="operator">=</span> <span class="number">40</span>;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br></pre></td></tr></table></figure><p><strong><em>IO</em> 流 ，新建一个文件，使用StringBuffer建立缓冲<br>在这段代码中，“end:” 是一个标签（label）。<br>它主要用于在嵌套的循环中，<br>配合<code>break</code>语句实现跳出多层循环的目的。<br>在这个特定的代码片段中，<br>当满足特定条件（读取到文件末尾，即<code>len == -1</code>且状态设置为<code>StatusLastFrame</code>）时，使用<code>break end;</code>语句可以直接跳出最外层的<code>while (true)</code>循环。<br>如果没有这个标签，<code>break</code>语句只能跳出最内层的循环或<code>switch</code>语句。</strong></p><p>&#x3D;&#x3D;<strong>创建一个Json对象data 用于传输数据</strong>&#x3D;&#x3D;</p><ul><li><em>*<em>common.addProperty</em> 中 common是JonObject中一个对象，*business</em>同理，向讯飞服务器传输信息。下面传输的是api_id和选择的语言**</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 音频的状态  </span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;  </span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[frameSize];  </span><br><span class="line">    <span class="comment">// 发送音频  </span></span><br><span class="line">    end:  </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fs.read(buffer);  </span><br><span class="line">        <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;  </span><br><span class="line">            status = StatusLastFrame; </span><br><span class="line">             <span class="comment">//文件读完，改变status 为 2                &#125;  </span></span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;  </span><br><span class="line">            <span class="keyword">case</span> StatusFirstFrame:   </span><br><span class="line">            <span class="comment">// 第一帧音频status = 0  </span></span><br><span class="line">                <span class="type">JsonObject</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonObject</span>();  </span><br><span class="line">                <span class="type">JsonObject</span> <span class="variable">business</span> </span><br><span class="line">                <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonObject</span>();  </span><br><span class="line">                <span class="comment">//第一帧必须发送  </span></span><br><span class="line">                <span class="type">JsonObject</span> <span class="variable">common</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonObject</span>();  </span><br><span class="line">                <span class="comment">//第一帧必须发送  </span></span><br><span class="line">                <span class="type">JsonObject</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonObject</span>();  </span><br><span class="line">                <span class="comment">//每一帧都要发送  </span></span><br><span class="line">                <span class="comment">// 填充common  </span></span><br><span class="line">                common.addProperty(<span class="string">&quot;app_id&quot;</span>, appid);  </span><br><span class="line">                <span class="comment">//填充business  </span></span><br><span class="line">                business.addProperty(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;zh_cn&quot;</span>);  </span><br></pre></td></tr></table></figure><p>**其他语音选择 （无需在意）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//business.addProperty(&quot;language&quot;, &quot;en_us&quot;);//英文  </span><br><span class="line">//business.addProperty(&quot;language&quot;, &quot;ja_jp&quot;);//日语，在控制台可添加试用或购买  </span><br><span class="line">//business.addProperty(&quot;language&quot;, &quot;ko_kr&quot;);//韩语，在控制台可添加试用或购买  </span><br><span class="line">//business.addProperty(&quot;language&quot;, &quot;ru-ru&quot;);//俄语，在控制台可添加试用或购买  </span><br><span class="line">business.addProperty(&quot;domain&quot;, &quot;iat&quot;);  </span><br><span class="line">business.addProperty(&quot;accent&quot;, &quot;mandarin&quot;);//中文方言请在控制台添加试用，添加后即展示相应参数值  </span><br><span class="line">//business.addProperty(&quot;nunum&quot;, 0);  </span><br><span class="line">//business.addProperty(&quot;ptt&quot;, 0);//标点符号  </span><br><span class="line">//business.addProperty(&quot;rlang&quot;, &quot;zh-hk&quot;); // zh-cn :简体中文（默认值）zh-hk :繁体香港(若未授权不生效，在控制台可免费开通)  </span><br><span class="line">//business.addProperty(&quot;vinfo&quot;, 1);                        business.addProperty(&quot;dwa&quot;, &quot;wpgs&quot;);//动态修正(若未授权不生效，在控制台可免费开通)  </span><br><span class="line">//business.addProperty(&quot;nbest&quot;, 5);// 句子多候选(若未授权不生效，在控制台可免费开通)  </span><br><span class="line">//business.addProperty(&quot;wbest&quot;, 3);// 词级多候选(若未授权不生效，在控制台可免费开通)  </span><br><span class="line">//填充data  </span><br><span class="line">data.addProperty(&quot;status&quot;, StatusFirstFrame);  </span><br><span class="line">data.addProperty(&quot;format&quot;, &quot;audio/L16;rate=16000&quot;);  </span><br><span class="line">data.addProperty(&quot;encoding&quot;, &quot;raw&quot;);  </span><br><span class="line">data.addProperty(&quot;audio&quot;, Base64.getEncoder().encodeToString(Arrays.copyOf(buffer, len)));  </span><br></pre></td></tr></table></figure><h4 id="填充要发送的帧"><a href="#填充要发送的帧" class="headerlink" title="填充要发送的帧"></a>填充要发送的帧</h4><h4 id="头帧"><a href="#头帧" class="headerlink" title="头帧"></a>头帧</h4><ul><li>*<em>将之前准备的</em>common,business和data * 这几个 <em>JsonObject</em>对象 添加到一个新的jsonObect对象帧中，对应与他们同名的键值。这样构成一个完整的数据请求结构，包含了应用信息，业务参数和音频数据信息**</li><li>**在通过<code>webSocket.send(frame.toString())</code>**把这个json信息帧发送出去，且这一部分作为帧头。</li><li><strong>完成后，将<em>status</em>状态 设置为<em>StatusContineFrame</em>标示接下来发送中间帧</strong></li></ul><p>其实我觉得还是很好理解的，先发送标示告诉服务器自己需要什么样的服务并提供自己的资质，然后再把数据给对方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//填充frame  </span></span><br><span class="line">frame.add(<span class="string">&quot;common&quot;</span>, common);  </span><br><span class="line">frame.add(<span class="string">&quot;business&quot;</span>, business);  </span><br><span class="line">frame.add(<span class="string">&quot;data&quot;</span>, data);  </span><br><span class="line">webSocket.send(frame.toString());                        status = StatusContinueFrame;  </span><br><span class="line"><span class="comment">// 发送完第一帧改变status 为 1                       </span></span><br><span class="line"> <span class="keyword">break</span>;  </span><br></pre></td></tr></table></figure><h4 id="中间帧"><a href="#中间帧" class="headerlink" title="中间帧"></a>中间帧</h4><p>**创建新的JsonObject对象frame1和data1<br>data1对象添加属性 ：</p><ul><li>**status 状态 – StatusContinueFrame 标识中间帧</li><li>**fromat 格式 –“audio&#x2F;L16;rate&#x3D;1600”即16位现行PCM编码，采样率是16000Hz</li><li>**<a href="#%E5%B8%B8%E9%87%8F">encoding</a>设置为raw,标示为原始编码</li><li>**audio 通过 <code>data1.addProperty(&quot;audio&quot;,Base64.getEncoder().encodeToString(Arrays.copyof(buffer,len)));</code>这个函数来读取音频数据，存储在buffer中，转换为Base64编码字符串</li><li>**将data1添加到frame1中，键为data</li><li>**最后通过webSocket.send(frame1.toString())发送数据</li></ul><hr><blockquote><p>个人理解：就是将音频转换为字符流，流式传输给服务器，剩下的交给服务器解决。我们稍微解决一些编码格式的问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> StatusContinueFrame:  </span><br><span class="line"><span class="comment">//中间帧status = 1  </span></span><br><span class="line">    <span class="type">JsonObject</span> <span class="variable">frame1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonObject</span>();  </span><br><span class="line">    <span class="type">JsonObject</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonObject</span>();  </span><br><span class="line">    data1.addProperty(<span class="string">&quot;status&quot;</span>, StatusContinueFrame);  </span><br><span class="line">    data1.addProperty(<span class="string">&quot;format&quot;</span>, <span class="string">&quot;audio/L16;rate=16000&quot;</span>);  </span><br><span class="line">    data1.addProperty(<span class="string">&quot;encoding&quot;</span>, <span class="string">&quot;raw&quot;</span>);  </span><br><span class="line">    data1.addProperty(<span class="string">&quot;audio&quot;</span>, Base64.getEncoder().encodeToString(Arrays.copyOf(buffer, len)));  </span><br><span class="line">    frame1.add(<span class="string">&quot;data&quot;</span>, data1);  </span><br><span class="line">    webSocket.send(frame1.toString());                        <span class="comment">// System.out.println(&quot;send continue&quot;);  </span></span><br><span class="line">    <span class="keyword">break</span>;  </span><br></pre></td></tr></table></figure><h4 id="尾帧"><a href="#尾帧" class="headerlink" title="尾帧"></a>尾帧</h4><p>**和前面一样改变标识符 status 为statusLatFrame，标示这是帧末尾<br>同样创建两个jsonObject对象，且给他们添加对应的属性</p><p>**其中 audio为空字符串，因为此处音频已经读取完，并没有实际的音频数据<br>但是我们同样设置格式为<code>audio/L16;rate=16000</code>和编码为“raw”</p><blockquote><p>&#x3D;&#x3D;此处是保持请求结构的一致性，即使audio为空，格式也应和前面一致。<br>且格式一致但是为空可以表示音频已经读取完毕没有后续，方便服务器处理。&#x3D;&#x3D;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> StatusLastFrame:    <span class="comment">// 最后一帧音频status = 2 ，标志音频发送结束  </span></span><br><span class="line">                <span class="type">JsonObject</span> <span class="variable">frame2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonObject</span>();  </span><br><span class="line">                <span class="type">JsonObject</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonObject</span>();  </span><br><span class="line">                data2.addProperty(<span class="string">&quot;status&quot;</span>, StatusLastFrame);  </span><br><span class="line">                data2.addProperty(<span class="string">&quot;audio&quot;</span>, <span class="string">&quot;&quot;</span>);  </span><br><span class="line">                data2.addProperty(<span class="string">&quot;format&quot;</span>, <span class="string">&quot;audio/L16;rate=16000&quot;</span>);  </span><br><span class="line">                data2.addProperty(<span class="string">&quot;encoding&quot;</span>, <span class="string">&quot;raw&quot;</span>);  </span><br><span class="line">                frame2.add(<span class="string">&quot;data&quot;</span>, data2);  </span><br><span class="line">                webSocket.send(frame2.toString());                        System.out.println(<span class="string">&quot;sendlast&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span> end;  </span><br><span class="line">        &#125;                Thread.sleep(intervel); </span><br><span class="line">        <span class="comment">//模拟音频采样延时  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(<span class="string">&quot;all data is send&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环与异常处理"><a href="#循环与异常处理" class="headerlink" title="循环与异常处理"></a>循环与异常处理</h4><p>普通的抛异常和启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">            e.printStackTrace();        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();        &#125;    &#125;).start();&#125;</span><br></pre></td></tr></table></figure><h2 id="onMessage"><a href="#onMessage" class="headerlink" title="onMessage"></a>onMessage</h2><p><strong>onmessage最终效果如图</strong></p><p>![[Pasted image 20241030194603.png]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(WebSocket webSocket, String text)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.onMessage(webSocket, text);  </span><br><span class="line">    <span class="comment">//System.out.println(text);  </span></span><br><span class="line">    <span class="type">ResponseData</span> <span class="variable">resp</span> <span class="operator">=</span> </span><br><span class="line">    json.fromJson(text, ResponseData.class);  </span><br><span class="line">    <span class="keyword">if</span> (resp != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (resp.getCode() != <span class="number">0</span>) </span><br><span class="line">        &#123;  System.out.println( <span class="string">&quot;code=&gt;&quot;</span> + resp.getCode() </span><br><span class="line">        + <span class="string">&quot; error=&gt;&quot;</span> + resp.getMessage() +</span><br><span class="line">        + <span class="string">&quot; sid=&quot;</span> + resp.getSid());  </span><br><span class="line">            System.out.println( </span><br><span class="line">            <span class="string">&quot;错误码查询链接：</span></span><br><span class="line"><span class="string">            https://www.xfyun.cn/document/error-code&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span> (resp.getData() != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (resp.getData().getResult() != <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="type">Text</span> <span class="variable">te</span> <span class="operator">=</span> </span><br><span class="line">                resp.getData().getResult().getText();                </span><br><span class="line">                <span class="comment">//System.out.println(te.toString());  </span></span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    decoder.decode(te);                   </span><br><span class="line">                    System.out.println(<span class="string">&quot;中间识别结果 ==》&quot;</span> + decoder.toString());  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    e.printStackTrace();                &#125;            &#125;            <span class="keyword">if</span> (resp.getData().getStatus() == <span class="number">2</span>) &#123;  </span><br><span class="line">                <span class="comment">// todo  resp.data.status ==2 说明数据全部返回完毕，可以关闭连接，释放资源  </span></span><br><span class="line">                System.out.println(<span class="string">&quot;session end &quot;</span>);  </span><br><span class="line">                dateEnd = <span class="keyword">new</span> <span class="title class_">Date</span>();  </span><br><span class="line">                System.out.println(sdf.format(dateBegin) + <span class="string">&quot;开始&quot;</span>);  </span><br><span class="line">                System.out.println(sdf.format(dateEnd) + <span class="string">&quot;结束&quot;</span>);  </span><br><span class="line">                System.out.println(<span class="string">&quot;耗时:&quot;</span> + (dateEnd.getTime() - dateBegin.getTime()) + <span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">                System.out.println(<span class="string">&quot;最终识别结果 ==》&quot;</span> + decoder.toString());  </span><br><span class="line">                System.out.println(<span class="string">&quot;本次识别sid ==》&quot;</span> + resp.getSid());  </span><br><span class="line">                decoder.discard();                webSocket.close(<span class="number">1000</span>, <span class="string">&quot;&quot;</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// todo 根据返回的数据处理  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>重写了<code>onMessage</code>方法，在接收到服务器消息时被调用。</li><li>将接收到的字符串转换为<code>ResponseData</code>对象。</li><li>如果返回的代码不为 0，则打印错误信息并提供错误码查询链接。</li><li>如果数据不为空且结果不为空，调用<code>decoder.decode</code>方法解析中间结果，并打印中间识别结果。</li><li>如果数据状态为 2，表示数据全部返回完毕，打印结束信息、耗时、最终识别结果和识别 ID，然后调用<code>decoder.discard</code>方法释放资源，并关闭 WebSocket 连接。</li></ul><h2 id="onFailure"><a href="#onFailure" class="headerlink" title="onFailure"></a>onFailure</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(WebSocket webSocket, Throwable t, Response response)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.onFailure(webSocket, t, response);  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != response) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> response.code();  </span><br><span class="line">            System.out.println(<span class="string">&quot;onFailure code:&quot;</span> + code);  </span><br><span class="line">            System.out.println(<span class="string">&quot;onFailure body:&quot;</span> + response.body().string());  </span><br><span class="line">            <span class="keyword">if</span> (<span class="number">101</span> != code) &#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;connection failed&quot;</span>);  </span><br><span class="line">                System.exit(<span class="number">0</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重写了<code>onFailure</code>方法，在连接失败时被调用。</li><li>打印失败代码和响应体内容。</li><li>如果响应代码不是 101，则表示连接失败，打印错误信息并退出程序。</li></ul><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><ul><li><p><code>main</code>方法是程序的入口点。</p></li><li><p>调用<code>getAuthUrl</code>方法构建鉴权 URL。</p></li><li><p>创建<code>OkHttpClient</code>对象。</p></li><li><p>将鉴权 URL 的 HTTP 或 HTTPS 协议替换为 WebSocket 协议（ws:&#x2F;&#x2F; 或 wss:&#x2F;&#x2F;）。</p></li><li><p>创建<code>Request</code>对象并传入鉴权后的 URL。</p><blockquote><p><strong>鉴权 URL（Authentication URL）是一种经过特定认证机制处理后的 URL，用于确保对特定资源的访问是经过授权的。<br>就是把id和key传过去</strong></p></blockquote></li><li><p>使用<code>OkHttpClient</code>创建 WebSocket 连接，并传入<code>Request</code>对象和<code>WebIATWS</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="comment">// 构建鉴权url  </span></span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">authUrl</span> <span class="operator">=</span> getAuthUrl(hostUrl, apiKey, apiSecret);  </span><br><span class="line">    <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().build();  </span><br><span class="line">    <span class="comment">//将url中的 schema http://和https://分别替换为ws:// 和 wss://</span></span><br></pre></td></tr></table></figure></li><li><p>将鉴权后的 URL 的 HTTP 或 HTTPS 协议替换为 WebSocket 协议（ws:&#x2F;&#x2F; 或 wss:&#x2F;&#x2F;）。这是因为 WebSocket 连接使用不同的协议来与服务器进行通信。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> authUrl.toString().replace(<span class="string">&quot;http://&quot;</span>, <span class="string">&quot;ws://&quot;</span>).replace(<span class="string">&quot;https://&quot;</span>, <span class="string">&quot;wss://&quot;</span>);  </span><br><span class="line">    <span class="comment">//System.out.println(url);  </span></span><br><span class="line">    </span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(url).build(); </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// System.out.println(client.newCall(request).execute());  </span></span><br><span class="line">    <span class="comment">//System.out.println(&quot;url===&gt;&quot; + url);   </span></span><br><span class="line">    </span><br><span class="line"><span class="type">WebSocket</span> <span class="variable">webSocket</span> <span class="operator">=</span> client.newWebSocket(request, </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">WebIATWS</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<code>WebSocket webSocket = client.newWebSocket(request, new WebIATWS());</code></p><ul><li>**使用<code>OkHttpClient</code>实例创建一个 WebSocket 连接。这里传入了<code>Request</code>对象和一个<code>WebIATWS</code>实例，<code>WebIATWS</code>是一个自定义的类，继承自<code>WebSocketListener</code>，用于处理 WebSocket 连接的各种事件，如连接成功（<code>onOpen</code>）、接收消息（<code>onMessage</code>）和连接失败（<code>onFailure</code>）。</li></ul><p>在 Java 中，<code>main</code>方法是程序的入口点，主要用于启动程序的执行流程，而<code>onOpen</code>、<code>onMessage</code>和<code>onFailure</code>是特定类（这里是<code>WebIATWS</code>类，它继承自<code>WebSocketListener</code>）的方法，用于处理 WebSocket 连接的特定事件。</p><p><code>main</code>方法通常负责设置和启动程序的主要逻辑，在这段代码中，它的主要作用是构建鉴权 URL、创建<code>OkHttpClient</code>、建立 WebSocket 连接等操作。而<code>onOpen</code>、<code>onMessage</code>和<code>onFailure</code>方法是在特定的事件发生时由系统自动调用的回调方法。</p><p><strong>具体来说：</strong></p><ul><li>**<code>onOpen</code>方法在 WebSocket 连接成功建立时被调用。</li><li>**<code>onMessage</code>方法在接收到服务器发送的消息时被调用。</li><li>**<code>onFailure</code>方法在连接出现故障时被调用。<br>这些方法的调用时机是由 WebSocket 通信的流程和系统事件触发机制决定的，而不是在<code>main</code>方法中直接调用。所以在<code>main</code>方法中看不到这些方法的调用是正常的。</li></ul><h2 id="getAuthUrl"><a href="#getAuthUrl" class="headerlink" title="getAuthUrl"></a>getAuthUrl</h2><p><strong>这一部分主要是进行一些加密和字符编码，并且获取一些主机信息作为鉴权URL发送给服务器</strong></p><blockquote><ul><li>用于构建鉴权 URL。</li></ul></blockquote><ul><li>创建<code>URL</code>对象并获取主机名和路径。</li><li>使用特定格式的<code>SimpleDateFormat</code>获取当前日期时间，并设置为 GMT 时区。</li><li>构建请求字符串，并使用 HMAC-SHA256 算法计算签名。</li><li>构建授权字符串，并将其作为查询参数添加到 URL 中，最终返回鉴权后的 URL。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getAuthUrl</span><span class="params">(String hostUrl, String apiKey, String apiSecret)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(hostUrl);  </span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;EEE, dd MMM yyyy HH:mm:ss z&quot;</span>, Locale.US);  </span><br><span class="line">    </span><br><span class="line">    format.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;GMT&quot;</span>));  </span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> format.format(<span class="keyword">new</span> <span class="title class_">Date</span>());  </span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;host: &quot;</span>).append(url.getHost()).append(<span class="string">&quot;\n&quot;</span>).<span class="comment">//  </span></span><br><span class="line">            append(<span class="string">&quot;date: &quot;</span>).append(date).append(<span class="string">&quot;\n&quot;</span>).<span class="comment">//  </span></span><br><span class="line">            append(<span class="string">&quot;GET &quot;</span>).append(url.getPath()).append(<span class="string">&quot; HTTP/1.1&quot;</span>);  </span><br><span class="line">            </span><br><span class="line">    <span class="comment">//System.out.println(builder);  </span></span><br><span class="line">    </span><br><span class="line">    <span class="type">Charset</span> <span class="variable">charset</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);  </span><br><span class="line">    <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(<span class="string">&quot;hmacsha256&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="type">SecretKeySpec</span> <span class="variable">spec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(apiSecret.getBytes(charset), <span class="string">&quot;hmacsha256&quot;</span>);  </span><br><span class="line">    mac.init(spec);  </span><br><span class="line">    <span class="type">byte</span>[] hexDigits = mac.doFinal(builder.toString().getBytes(charset));  </span><br><span class="line">    <span class="type">String</span> <span class="variable">sha</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(hexDigits);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println(sha);  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> String.format(<span class="string">&quot;api_key=\&quot;%s\&quot;, algorithm=\&quot;%s\&quot;, headers=\&quot;%s\&quot;, signature=\&quot;%s\&quot;&quot;</span>, apiKey, <span class="string">&quot;hmac-sha256&quot;</span>, <span class="string">&quot;host date request-line&quot;</span>, sha);  </span><br><span class="line">    <span class="comment">//System.out.println(authorization);  </span></span><br><span class="line">    <span class="type">HttpUrl</span> <span class="variable">httpUrl</span> <span class="operator">=</span> HttpUrl.parse(<span class="string">&quot;https://&quot;</span> + url.getHost() + url.getPath()).newBuilder().<span class="comment">//  </span></span><br><span class="line">            addQueryParameter(<span class="string">&quot;authorization&quot;</span>, Base64.getEncoder().encodeToString(authorization.getBytes(charset))).<span class="comment">//  </span></span><br><span class="line">            addQueryParameter(<span class="string">&quot;date&quot;</span>, date).<span class="comment">//  </span></span><br><span class="line">            addQueryParameter(<span class="string">&quot;host&quot;</span>, url.getHost()).<span class="comment">//  </span></span><br><span class="line">            build();  </span><br><span class="line">    <span class="keyword">return</span> httpUrl.toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部定义类部分"><a href="#内部定义类部分" class="headerlink" title="内部定义类部分"></a>内部定义类部分</h2><h3 id="ResponseData"><a href="#ResponseData" class="headerlink" title="ResponseData"></a>ResponseData</h3><p>**用于封装服务器返回的响应数据，包含错误代码、错误信息、识别 ID 和具体数据对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ResponseData</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;  </span><br><span class="line">    <span class="keyword">private</span> String message;  </span><br><span class="line">    <span class="keyword">private</span> String sid;  </span><br><span class="line">    <span class="keyword">private</span> Data data;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> code;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.message;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSid</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> sid;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> data;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p> **表示服务器返回数据中的一部分，包含状态码和结果对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Data</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> status;  </span><br><span class="line">    <span class="keyword">private</span> Result result;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStatus</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> status;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getResult</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><ul><li>表示服务器返回结果中的具体内容，包含起始位置、结束位置、页码、范围、序号、词序列、是否最后一页和语音活动检测对象等信息，并提供获取文本对象的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;  </span><br><span class="line">    <span class="type">int</span> bg;  </span><br><span class="line">    <span class="type">int</span> ed;  </span><br><span class="line">    String pgs;  </span><br><span class="line">    <span class="type">int</span>[] rg;  </span><br><span class="line">    <span class="type">int</span> sn;  </span><br><span class="line">    Ws[] ws;  </span><br><span class="line">    <span class="type">boolean</span> ls;  </span><br><span class="line">    JsonObject vad;  </span><br><span class="line">    <span class="keyword">public</span> Text <span class="title function_">getText</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">Text</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();  </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">        <span class="keyword">for</span> (Ws ws : <span class="built_in">this</span>.ws) &#123;  </span><br><span class="line">            sb.append(ws.cw[<span class="number">0</span>].w);  </span><br><span class="line">        &#125;  </span><br><span class="line">        text.sn = <span class="built_in">this</span>.sn;  </span><br><span class="line">        text.text = sb.toString();  </span><br><span class="line">        text.sn = <span class="built_in">this</span>.sn;  </span><br><span class="line">        text.rg = <span class="built_in">this</span>.rg;  </span><br><span class="line">        text.pgs = <span class="built_in">this</span>.pgs;  </span><br><span class="line">        text.bg = <span class="built_in">this</span>.bg;  </span><br><span class="line">        text.ed = <span class="built_in">this</span>.ed;  </span><br><span class="line">        text.ls = <span class="built_in">this</span>.ls;  </span><br><span class="line">        text.vad = <span class="built_in">this</span>.vad==<span class="literal">null</span> ? <span class="literal">null</span> : <span class="built_in">this</span>.vad;  </span><br><span class="line">        <span class="keyword">return</span> text;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="Ws-word-start"><a href="#Ws-word-start" class="headerlink" title="Ws  word-start"></a>Ws  word-start</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Ws</span> &#123; Cw[] cw; <span class="type">int</span> bg; <span class="type">int</span> ed; &#125;</span><br></pre></td></tr></table></figure><h3 id="Cw"><a href="#Cw" class="headerlink" title="Cw"></a>Cw</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Cw</span> &#123; <span class="type">int</span> sc; String w; &#125;</span><br></pre></td></tr></table></figure><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;  </span><br><span class="line">    <span class="type">int</span> sn;  </span><br><span class="line">    <span class="type">int</span> bg;  </span><br><span class="line">    <span class="type">int</span> ed;  </span><br><span class="line">    String text;  </span><br><span class="line">    String pgs;  </span><br><span class="line">    <span class="type">int</span>[] rg;  </span><br><span class="line">    <span class="type">boolean</span> deleted;  </span><br><span class="line">    <span class="type">boolean</span> ls;  </span><br><span class="line">    JsonObject vad;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Text&#123;&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;bg=&quot;</span> + bg +  </span><br><span class="line">                <span class="string">&quot;, ed=&quot;</span> + ed +  </span><br><span class="line">                <span class="string">&quot;, ls=&quot;</span> + ls +  </span><br><span class="line">                <span class="string">&quot;, sn=&quot;</span> + sn +  </span><br><span class="line">                <span class="string">&quot;, text=&#x27;&quot;</span> + text + <span class="string">&#x27;\&#x27;&#x27;</span> +  </span><br><span class="line">                <span class="string">&quot;, pgs=&quot;</span> + pgs +  </span><br><span class="line">                <span class="string">&quot;, rg=&quot;</span> + Arrays.toString(rg) +  </span><br><span class="line">                <span class="string">&quot;, deleted=&quot;</span> + deleted +  </span><br><span class="line">                <span class="string">&quot;, vad=&quot;</span> + (vad==<span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : vad.getAsJsonArray(<span class="string">&quot;ws&quot;</span>).toString()) +  </span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//解析返回数据，仅供参考</span></span><br></pre></td></tr></table></figure><h3 id="Decoder-类"><a href="#Decoder-类" class="headerlink" title="Decoder 类"></a>Decoder 类</h3><ul><li>主要用于解析服务器返回的数据。</li><li>包含成员变量<code>texts</code>（<code>Text</code>对象数组）和<code>defc</code>（初始数组大小）。</li><li><code>public Decoder()</code>构造函数初始化<code>texts</code>数组。</li><li><code>synchronized void decode(Text text)</code>方法用于解析单个<code>Text</code>对象，如果序号超过当前数组大小，会调用<code>resize</code>方法扩展数组；如果特定条件满足，会设置相应元素的<code>deleted</code>标志位；最后将传入的<code>Text</code>对象放入数组对应位置。</li><li><code>String toString()</code>方法用于将未被删除的<code>Text</code>对象的文本内容拼接起来返回。</li><li><code>void resize()</code>方法用于扩展<code>texts</code>数组，将数组大小翻倍，并复制旧数组的内容到新数组。</li><li><code>void discard()</code>方法用于将<code>texts</code>数组中的所有元素置为<code>null</code>，可能是用于释放资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Decoder</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Text[] texts;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">defc</span> <span class="operator">=</span> <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decoder</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.texts = <span class="keyword">new</span> <span class="title class_">Text</span>[<span class="built_in">this</span>.defc];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(Text text)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (text.sn &gt;= <span class="built_in">this</span>.defc) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.resize();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;rpl&quot;</span>.equals(text.pgs)) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> text.rg[<span class="number">0</span>]; i &lt;= text.rg[<span class="number">1</span>]; i++) &#123;  </span><br><span class="line">                <span class="built_in">this</span>.texts[i].deleted = <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">this</span>.texts[text.sn] = text;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">            <span class="keyword">for</span> (Text t : <span class="built_in">this</span>.texts) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; !t.deleted) &#123;  </span><br><span class="line">                    sb.append(t.text);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> sb.toString();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">oc</span> <span class="operator">=</span> <span class="built_in">this</span>.defc;  </span><br><span class="line">            <span class="built_in">this</span>.defc &lt;&lt;= <span class="number">1</span>;  </span><br><span class="line">            Text[] old = <span class="built_in">this</span>.texts;  </span><br><span class="line">            <span class="built_in">this</span>.texts = <span class="keyword">new</span> <span class="title class_">Text</span>[<span class="built_in">this</span>.defc];  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oc; i++) &#123;  </span><br><span class="line">                <span class="built_in">this</span>.texts[i] = old[i];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discard</span><span class="params">()</span>&#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">this</span>.texts.length;i++)&#123;  </span><br><span class="line">                <span class="built_in">this</span>.texts[i]= <span class="literal">null</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在安卓程序中调用摄像头</title>
      <link href="/2025/04/17/web/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/"/>
      <url>/2025/04/17/web/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="调用相机"><a href="#调用相机" class="headerlink" title="调用相机"></a>调用相机</h1><p>[[#layout]]<br>[[#mainActivity.java]]<br>[[#AndroidManifest.xml]]<br>[[#@xml&#x2F;paths]]<br>[[#log以及报错问题]]</p><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/take_photo&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:text</span>=<span class="string">&quot;take it&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/photo&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;145dp&quot;</span>  </span></span><br><span class="line"><span class="tag">  </span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;&#x3D;&#x3D;布局使用了constratlayout，使用了一个按钮控件和一个，imageView控件，imageView控件没有设置图片&#x3D;&#x3D;</p><p>  <a href="#%E8%B0%83%E7%94%A8%E7%9B%B8%E6%9C%BA">返回标题</a></p><h2 id="mainActivity-java"><a href="#mainActivity-java" class="headerlink" title="mainActivity.java"></a>mainActivity.java</h2><p>import 内容省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.tackemac;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TAKE_PHOTO</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">private</span> ImageView picture;  </span><br><span class="line"><span class="keyword">private</span> Uri imageUri;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;  </span><br><span class="line"><span class="built_in">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">setContentView(R.layout.activity_main);  </span><br><span class="line">``````</span><br><span class="line"><span class="comment">//==onCreate 函数重写，绑定mainactivity.==</span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="type">Button</span> <span class="variable">takePhoto</span> <span class="operator">=</span> (Button) findViewById(R.id.take_photo);  </span><br><span class="line">picture = (ImageView) findViewById(R.id.photo);</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;&#x3D;&#x3D;控件ID绑定&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">takePhoto.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;  </span><br><span class="line">Log.e(TAG,<span class="string">&quot;onclickstart&quot;</span>);  </span><br><span class="line"><span class="type">File</span> <span class="variable">outputImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getExternalCacheDir(),  </span><br><span class="line"><span class="string">&quot;output_image.jpg&quot;</span>);  </span><br><span class="line">``````</span><br><span class="line"><span class="comment">//==点击事件==</span></span><br><span class="line"><span class="comment">// ==IO流，将图片存储到output_image.jpg中</span></span><br><span class="line"><span class="comment">//CacheDir--外部缓存地址==</span></span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line"><span class="keyword">if</span> (outputImage.exists()) &#123;  </span><br><span class="line">outputImage.delete();  </span><br><span class="line">&#125;  </span><br><span class="line">outputImage.createNewFile();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;&#x3D;&#x3D;捕获异常，检测是否存在相同照片&#x3D;&#x3D;<br>&#x2F;&#x2F;&#x3D;&#x3D;检测SDK版本，做不同版本的适配↓&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;  </span><br><span class="line">Log.e(TAG,<span class="string">&quot;onclickif&quot;</span>);  </span><br><span class="line">imageUri = FileProvider.getUriForFile(MainActivity.<span class="built_in">this</span>,  </span><br><span class="line"><span class="string">&quot;com.exanple.cameraablumtest.flieprovider&quot;</span>,  </span><br><span class="line">outputImage);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">imageUri = Uri.fromFile(outputImage);  </span><br><span class="line">&#125;  </span><br><span class="line">Log.e(TAG,<span class="string">&quot;newintent&quot;</span>);  </span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;&#x3D;&#x3D;跳转到系统相机中&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;android.media.action.IMAGE_CAPTURE&quot;</span>);  </span><br><span class="line">Log.e(TAG,<span class="string">&quot;intent&quot;</span>);  </span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);  </span><br><span class="line"><span class="comment">// MainActivity.this.startActivityForResult(intent,TAKE_PHOTO);  </span></span><br><span class="line">startActivityForResult(intent, TAKE_PHOTO);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>&#x2F;*&#x3D;&#x3D;重写onActivityResult结果函数<br>request Code –启动活动请求,用于区分是哪个请求的结果<br>result Code –返回结果， result_OK标示成功。<br>Intent data –返回跳转的对象<br>Bitmap–一种照片图像数据的表示形式<br>BitmaoFactory.decodeStream –把获取的图片解码为bitmap图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> &#123;  </span><br><span class="line"><span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);  </span><br><span class="line">Log.e(TAG,<span class="string">&quot;onActiviyResult&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">switch</span> (requestCode) &#123;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">case</span> TAKE_PHOTO:  </span><br><span class="line"><span class="keyword">if</span> (resultCode == RESULT_OK) &#123;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeStream(  </span><br><span class="line">getContentResolver().openInputStream(imageUri));  </span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line"><span class="keyword">break</span>;  &#125;  </span><br><span class="line">&#125;  &#125;</span><br></pre></td></tr></table></figure><p>  <a href="#%E8%B0%83%E7%94%A8%E7%9B%B8%E6%9C%BA">返回标题</a></p><h2 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h2><p>&#x3D;&#x3D;获取的照相和存储权限&#x3D;&#x3D;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">package</span>=<span class="string">&quot;com.example.tackemac&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--声明访问SD卡权限↑--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">application</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Tackemac&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:authorities</span>=<span class="string">&quot;com.example.bicameralism.file-provider&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span>  </span></span><br><span class="line"><span class="tag">&lt;!<span class="attr">--</span> <span class="attr">请注意这里--</span>&gt;</span></span><br><span class="line">android:resource=&quot;@xml/file_paths&quot;/&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;指定Uri共享路径,@xml&#x2F;paths&#x3D;&#x3D;</p><p>  <a href="#%E8%B0%83%E7%94%A8%E7%9B%B8%E6%9C%BA">返回标题</a></p><h2 id="xml-paths"><a href="#xml-paths" class="headerlink" title="@xml&#x2F;paths"></a>@xml&#x2F;paths</h2><p>&#x3D;&#x3D;在res中新建一个xml文件夹，再在其中新建一个名为file_path.xml的文件&#x3D;&#x3D;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">external-path</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">name</span>=<span class="string">&quot;my_images&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">path</span>=<span class="string">&quot;output_image.jpg&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&lt;‘external-path’&gt;指定Uri共享,path表示具体路径，空值表示整个SD卡共享，这里仅共享ouput_image.jpg的路径&#x3D;&#x3D;</p><p>  <a href="#%E8%B0%83%E7%94%A8%E7%9B%B8%E6%9C%BA">返回标题</a></p><h2 id="log以及报错问题"><a href="#log以及报错问题" class="headerlink" title="log以及报错问题"></a>log以及报错问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  E  avc:  denied  &#123; find &#125; for service=netd pid=7894 uid=2000 scontext=u:r:shell:s0 tcontext=u:object_r:netd_service:s0 tclass=service_manager</span><br><span class="line">2024-10-14 19:40:05.070  1369-1369  SELinux                 servicemanager                       E  avc:  denied  &#123; find &#125; for service=android.service.gatekeeper.IGateKeeperService pid=7894 uid=2000 scontext=u:r:shell:s0 tcontext=u:object_r:gatekeeper_service:s0 tclass=service_manager</span><br><span class="line">2024-10-14 19:40:05.076  1369-1369  SELinux                 servicemanager                       E  avc:  denied  &#123; find &#125; for service=installd pid=7894 uid=2000 scontext=u:r:shell:s0 tcontext=u:object_r:installd_service:s0 tclass=service_manager</span><br><span class="line">2024-10-14 19:40:07.315  1700-1910  JavaBinder    </span><br><span class="line"></span><br><span class="line">system_server                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E  !!! FAILED BINDER TRANSACTION !!!  (parcel size = 108)</span><br><span class="line">//怀疑是传输问题，但是没有找到解决方法</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">==E  !!! FAILED BINDER TRANSACTION !!!  (parcel size = 108)</span><br><span class="line">//怀疑是传输问题，但是没有找到解决方法</span><br><span class="line">//android似乎对图片传输大小有限制，看网上的各种方法没有完全理解</span><br><span class="line">```log</span><br><span class="line">2024-10-14 19:40:08.106  7938-7962  &lt;no-tag&gt;                com.example.tackemac                 D  HostConnection::get() New Host Connection established 0xa2c76140, tid 7962</span><br><span class="line">2024-10-14 19:40:10.572  1369-1369  SELinux                 servicemanager                       E  avc:  denied  &#123; find &#125; for service=netd pid=7966 uid=2000 scontext=u:r:shell:s0 tcontext=u:object_r:netd_service:s0 tclass=service_manager</span><br><span class="line">2024-10-14 19:40:10.574  1369-1369  SELinux                 servicemanager                       E  avc:  denied  &#123; find &#125; for service=android.service.gatekeeper.IGateKeeperService pid=7966 uid=2000 scontext=u:r:shell:s0 tcontext=u:object_r:gatekeeper_service:s0 tclass=service_manager</span><br><span class="line">2024-10-14 19:40:10.575  1369-1369  SELinux                 servicemanager                       E  avc:  denied  &#123; find &#125; for service=installd pid=7966 uid=2000 sconte</span><br></pre></td></tr></table></figure><p>  <a href="#%E8%B0%83%E7%94%A8%E7%9B%B8%E6%9C%BA">返回标题</a></p><h2 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h2><p><a href="#%E8%B0%83%E7%94%A8%E7%9B%B8%E6%9C%BA">返回标题</a></p><h3 id="maiActivity-java"><a href="#maiActivity-java" class="headerlink" title="maiActivity.java"></a>maiActivity.java</h3><h4 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h4><p>&#x2F;*<br>    &#x3D;&#x3D;Oncreate函数绑定布局<br>    定义常量<br>    request_image_caputue &#x3D;1 – 请求图像捕捉；<br>    REQUEST_CAMERA_PERMISSION &#x3D; 100 –请求相机许可&#x3D;&#x3D;<br>*&#x2F;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST_IMAGE_CAPTURE</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST_CAMERA_PERMISSION</span> <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h4 id="Oncreate函数绑定布局"><a href="#Oncreate函数绑定布局" class="headerlink" title="Oncreate函数绑定布局"></a>Oncreate函数绑定布局</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;  </span><br><span class="line"><span class="built_in">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义常量-1"><a href="#定义常量-1" class="headerlink" title="定义常量"></a>定义常量</h4><p>&#x2F;*<br>    &#x3D;&#x3D;定义常量<br>    request_image_caputue &#x3D;1 – 请求图像捕捉；<br>    REQUEST_CAMERA_PERMISSION &#x3D; 100 –请求相机许可&#x3D;&#x3D;<br>*&#x2F;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takePictureIntent</span><span class="params">(View view)</span> &#123;  </span><br><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="built_in">this</span>, android.Manifest.permission.CAMERA)!= PackageManager.PERMISSION_GRANTED) &#123;  </span><br><span class="line">ActivityCompat.requestPermissions(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;android.Manifest.permission.CAMERA&#125;, REQUEST_CAMERA_PERMISSION);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">dispatchTakePictureIntent();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h4><p>&#x2F;*<br>    &#x3D;&#x3D;点击事件！<br>    判断是否拥有相机权限，如果没有就请求相机权限，如果有就使用Intent打开相机。<br>    GRANTED –授予<br>    if中<br>    ContextCompat.checkSelfPermission(this, android.Manifest.permission.CAMERA)!&#x3D; PackageManager.PERMISSION_GRANTED<br>    为授予权限的判定&#x3D;&#x3D;<br> *&#x2F;</p><h4 id="请求使用相机"><a href="#请求使用相机" class="headerlink" title="请求使用相机"></a>请求使用相机</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">dispatchTakePictureIntent</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">takePictureIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// display error state to the user</span></span><br><span class="line">        Log.e(<span class="string">&quot;WarningMsg&quot;</span>,<span class="string">&quot;相机打开失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;*<br>    &#x3D;&#x3D;使用Intent打开相机↑dispatchTakePictureIntent()<br>    这个名为<code>dispatchTakePictureIntent</code>的方法主要用于启动设备的相机应用以拍摄照片。<br>    —-<br>    传入一个请求码<code>REQUEST_IMAGE_CAPTURE</code>。当相机应用拍摄完照片后，结果会返回到调用这个方法的活动（Activity）中，通过重写<code>onActivityResult</code>方法可以处理拍摄后的照片数据。<br>    ——<br>    如果在尝试启动相机的过程中抛出了<code>ActivityNotFoundException</code>异常，说明设备上没有能够响应这个拍照意图的应用程序。此时会捕获这个异常，并在日志中打印错误信息“相机打开失败!”，&#x3D;&#x3D;<br> *&#x2F;</p><h4 id="请求认证"><a href="#请求认证" class="headerlink" title="请求认证"></a>请求认证</h4><p>&#x2F;*<br>    —-<br>    &#x3D;&#x3D;请求认证回调函数，public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults)请求权限成功之后，再次回调打开相机</p><hr><pre><code>- `requestCode`：用于区分不同的权限请求。这里通过与常量`REQUEST_CAMERA_PERMISSION`比较，确定是否是相机权限请求的结果。</code></pre><hr><pre><code>permissions`：一个字符串数组，包含被请求的权限名称。</code></pre><hr><pre><code>- `grantResults`：一个整数数组，对应`permissions`数组中的权限请求结果，`PackageManager.PERMISSION_GRANTED`表示权限被授予，`PackageManager.PERMISSION_DENIED`表示权限被拒绝。==↓</code></pre><p> *&#x2F;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequestPermissionsResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="type">int</span>[] grantResults)</span> &#123;  </span><br><span class="line"><span class="built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);  </span><br><span class="line"><span class="keyword">if</span> (requestCode == REQUEST_CAMERA_PERMISSION) &#123;  </span><br><span class="line"><span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;  </span><br><span class="line">dispatchTakePictureIntent();<span class="comment">//打开相机  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;无法获取拍照权限&quot;</span>, Toast.LENGTH_SHORT).show();  &#125;  </span><br><span class="line">&#125;  &#125;</span><br></pre></td></tr></table></figure><h4 id="把内容传入imageView"><a href="#把内容传入imageView" class="headerlink" title="把内容传入imageView"></a>把内容传入imageView</h4><p>&#x2F;*<br>    &#x3D;&#x3D;在拍照完成后，激活该方法，把照片数写入ImageView<br>    protected void onActivityResult(int requestCode, int resultCode, Intent data)<br>    - <code>requestCode</code>：用于区分不同的启动子活动的请求码。在这个例子中，通过与特定的常量<code>REQUEST_IMAGE_CAPTURE</code>进行比较，确定返回的结果是否来自相机拍照的请求。<br>    —<br>     <code>resultCode</code>：表示子活动的返回结果状态码。这里通过与<code>RESULT_OK</code>进行比较，确定拍照操作是否成功。<br>     —-<br>    -<code>Intent data</code>：子活动返回的包含数据的意图（Intent）对象。<br>    —-<br>    - 使用<code>findViewById(R.id.iv)</code>找到一个<code>ImageView</code>控件，然后通过<code>imageView.setImageBitmap(imageBitmap)</code>将拍摄的照片设置为这个<code>ImageView</code>的显示内容。↓↓<br>    &#x3D;&#x3D;<br> *&#x2F;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="keyword">if</span> (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123;</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">extras</span> <span class="operator">=</span> data.getExtras();</span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">imageBitmap</span> <span class="operator">=</span> (Bitmap) extras.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> findViewById(R.id.iv);</span><br><span class="line">        imageView.setImageBitmap(imageBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[返回标题](#调用相机)</span><br><span class="line">### AndroidMainfest.xml</span><br><span class="line"></span><br><span class="line">==权限添加==</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</span><br><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt;</span><br><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;</span><br></pre></td></tr></table></figure><p><a href="#%E8%B0%83%E7%94%A8%E7%9B%B8%E6%9C%BA">返回标题</a></p><h1 id="调用麦克风"><a href="#调用麦克风" class="headerlink" title="调用麦克风"></a>调用麦克风</h1>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机相关 </tag>
            
            <tag> 软件开发 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是一个测试文件</title>
      <link href="/2025/04/16/web/modle/%E5%88%9B%E5%BB%BA%E9%93%BE%E6%8E%A5/"/>
      <url>/2025/04/16/web/modle/%E5%88%9B%E5%BB%BA%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> cate </category>
          
          <category> sub_cate </category>
          
          <category> sub_sub_cate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tag1 </tag>
            
            <tag> tag2 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
